== Pseudo Code
What follows is the current pseudo code for my simple 6502 assembler.  It is a work in progress!


{{{
// Constants
const uint16_t expectedHiMem = 0x9600;      // DOS should be located above this address.
const uint16_t machineCodeReserve = 0x7600; // Start of the area to be reserved for our machine code and ProDOS buffers.
const uint16_t dosBufferSize = 1024;        // ProDOS keeps 1k of buffers just above HIMEM.
const uint16_t machineCodeStart = 0x7600 + dosBufferSize;   // Assembled program will start at this address.
const int16_t  opcodeCount = 14;            // The opcode table supports 14 addressing modes.
const int16_t  maxLabelCount = 256;         // The maximum number of labels to support.
const int16_t  testQueueStart = 0x300;      // Place unit test bytes in page 3.
const int16_t  testQueueEnd = 0x3FF;
const int16_t  testQueueSize = testQueueEnd - testQueueStart + 1;
const uint16_t equInvalid = 0x10000;
const int16_t  immediate = 0;
const int16_t  absolute = 1;
const int16_t  zeropage = 2;
const int16_t  implied = 3;
const int16_t  zeropageIndexedIndirect = 4;
const int16_t  indirectIndexed = 5;
const int16_t  zeropageIndexedX = 6;
const int16_t  zeropageIndexedY = 7;
const int16_t  absoluteIndexedX = 8;
const int16_t  absoluteIndexedY = 9;
const int16_t  relative = 10;
const int16_t  absoluteIndirect = 11;
const int16_t  absoluteIndexedIndirect = 12;
const int16_t  zeropageIndirect = 13;

// Globals
uint16_t programCounter;
uint16_t lineProgramCounter;
uint16_t equValue;

int16_t  listFlag;
int16_t  testFlag;
int16_t  instructionCount;
int16_t  directiveCount;
int16_t  lineLength;
int16_t  length;
int16_t  pass;
int16_t  found;
int16_t  expressionValue;
int16_t  dataLineLo;
int16_t  dataLineHi;
int16_t  dataPtrLo;
int16_t  dataPtrHi;
int16_t  sourceDataLineLo;
int16_t  sourceDataLineHi;
int16_t  sourceDataPtrLo;
int16_t  sourceDataPtrHi;
int16_t  labelIndex;
int16_t  symbolIndex;
int16_t  symbolCount;
int16_t  testQueueWrite;
int16_t  testQueueRead;
int16_t  testQueueCount;
int16_t  errorCount;
int16_t  openParen;
int16_t  closeParen;
int16_t  comma;
int16_t  emitByte;
int16_t  i;
int16_t  j;
int16_t  tempInt;
int16_t  retInt;

string   D$;
string   lineText;
string   label;
string   operator;
string   operand;
string   comments;
string   symbolName;
string   expression;
string   tempString;

int16_t  opcodes[];
int16_t  symbolValues[];
string   symbolNames[];


main()
{
    CLEAR   // Tell BASIC to discard all variables.
    init();
    openSource();
    PRINT "ASSEMBLY STARTED"
    pass = 1;
    runPass();
    rewindSource();
    pass = 2;
    runPass();
    verifyTestQueueEmpty();
    closeSource();
    printSummary();
    cleanup();
}

init()
{
    SPEED=255 // Make listing output as fast as possible.
    TEXT      // Make sure that we are in text mode.
    PRINT: PRINT CHR$(4);"PR#3" : HOME // Switch to 80 Column Mode.
    reserveMemoryForMachineCode();
    initVariables();
    countOpcodeTableEntries();
    saveSourceDataLocations();
}

reserveMemoryForMachineCode()
{
    // Check that HIMEM is where we expect it.
    programCounter = PEEK(0x74) << 8) | PEEK(0x73);
    if (programCounter == machineCodeReserve)
        return;
    if (programCounter != expectedHiMem)
    {
        PRINT "*HIMEM"
        STOP
    }
    
    // Make sure that BASIC program hasn't already overflowed into our machine code area.
    if (PEEK(0x6E) << 8) | PEEK(0x6D) >= machineCodeReserve)
    {
        PRINT "*NORAM"
        STOP
    }
    
    HIMEM: machineCodeReserve;
}

initVariables()
{
    // Initialize integers.
    listFlag = 1;
    testFlag = 0;
    instructionCount = 0;
    directiveCount = 0;
    symbolCount = 0;
    errorCount = 0;
    testQueueWrite = testQueueStart;
    testQueueRead = testQueueStart;
    testQueueCount = 0;

    // Initialize strings.
    D$ = CHRS(4);
    
    // Init array.
    DIM opcodes(opcodeCount-1)
    DIM symbolNames(maxLabelCount-1)
    DIM symbolValues(maxLabelCount-1)
}

// Example DATA statements for instruction opcode table.
// The first column is the mnemonic for the instruction.
// The rest of the columns are opcode value for the different addressing modes.
// The column order matches the table in the Apple IIe Technical Reference Manual.
// A value of 255 means that this addressing mode isn't supported for this instruction.
DATA "ADC", 105, 109, 101, 255, 97, 113, 117, 255, 125, 121, 255, 255, 255, 114
DATA "" // Terminates the table.

// Example DATA statements for directive table.
DATA "ASC", "DB", "DS", "DW", "EQU", "LST", "SAV", "TST"
DATA "" // Terminates the table.

// Example source code
DATA "LABEL BRA LABEL"
DATA "      SAV TEST.BIN"
DATA "      END"

countOpcodeTableEntries()
{
    for (;;)
    {
        READ tempString
        if (tempString == "")
            break;
        instructionCount++;
        skipOpcodeData();
    }
    for (;;)
    {
        READ tempString
        if (tempString == "")
            break;
        directiveCount++;
    }
}

skipOpcodeData()
{
    for (j = 0 ; j < opcodeCount ; j++)
        READ tempInt
}

saveSourceDataLocations()
{
    getCurrentDataLocations();
    sourceDataLineLo = dataLineLo;
    sourceDataLineHi = dataLineHi;
    sourceDataPtrLo = dataPtrLo;
    sourceDataPtrHi = dataPtrHi;
}

getCurrentDataLocations()
{
    dataLineLo = PEEK(0x7B);
    dataLineHi = PEEK(0x7C);
    dataPtrLo = PEEK(0x7D);
    dataPtrHi = PEEK(0x7E);
}

openSource()
{
    // Nothing to be done here as DATA pointer is already set and ready to read assembly source.
}

runPass()
{
    programCounter = machineCodeStart;
    for (;;)
    {
        fetchAndSplitNextLine();
        parseLine();
        if (operator == "END")
            return;
    }
}

fetchAndSplitNextLine()
{
    freeUnneededStrings();
    
    restoreDataLocations();
    READ lineText
    getCurrentDataLocations();
    
    lineLength = LEN(lineText);
    lineProgramCounter = programCounter;
    equValue = equInvalid;
    
    i = 1;
    extractNextField();
    if (retInt)
        return;
    label = tempString;
        
    extractNextField();
    if (retInt)
        return;
    operator = tempString;

    extractNextField();
    if (retInt)
        return;
    operand = tempString;

    extractNextField();
    if (!retInt)
    {
        printLineNumber();
        PRINT "EXTRA_INPUT"
    }
}

freeUnneededStrings()
{
    tempString = "";
    lineText = "";
    label = "";
    opcode = "";
    operand = "";
    comment = "";
    symbolName = "";
    expression = "";
    PRINT D$;"FRE(0)" // Free unused strings.
}

restoreDataLocations()
{
    POKE 0x7B, dataLineLo
    POKE 0x7C, dataLineHi
    POKE 0x7D, dataPtrLo
    POKE 0x7E, dataPtrHi
}

extractNextField()
{
    // Just return if we have already extracted all of the fields already.
    if (i == lineLength+1)
    {
        retInt = 1;
        return;
    }
    
    // Check for comment.
    if (MID$(lineText,i,1) == ";")
    {
        comment = MID$(lineText, i);
        retInt = 1;
        return;
    }
    
    // Not comment so extract field.
    findNextWhitespace();
    tempString = MID$(lineText, i, j-i);
    i = j;
    
    // Advance to start of next field.
    findNextNonWhitespace();
    i = j;
    
    retInt = 0;
    return;
}

findNextWhitespace()
{
    j = i;
    while (j <= lineLength)
    {
        if (MID$(lineText,j,1) == " ")
            return;
        j++;
    }
}

findNextNonWhitespace()
{
    j = i;
    while (j <= lineLength)
    {
        if (MID$(lineText,j,1) != " ")
            return;
        j++;
    }
}

printLineNumber()
{
    errorCount++;
    PRINT "LINE:"; dataLineHi*256 + dataLineLo ; " *";
}

parseLine()
{
    if (testFlag && pass==2)
        parseCommentForTestBytes();
    createLabelSymbolIfNeeded();
    found = 0;
    parseAs65c02Instruction();
    parseAsDirective();
    if (!found && operator != "END")
    {
        printLineNumber();
        PRINT "INVALID_OPCODE"
    }
    if (listFlag && pass==2)
        generateListOutput();
}

parseCommentForTestBytes()
{
    doesCommentContainTestData();
    if (!retInt)
        return;
    queueUpTestBytes();
}

doesCommentContainTestData()
{
    for (i = 2 ; i <= LEN(comments) ; i++)
    {
        tempString = MID$(comments, i, 1)
        if (tempString != " " && (tempString < "0" || tempString > "9") && (tempString < "A" || tempString > "F"))
        {
            retInt = 0;
            return;
        }
    }
    retInt = 1;
}

queueUpTestBytes()
{
    i = 2;
    while (i < LEN(comments))
    {
        skipSpaces();
        expression = MID$(comments, i, 2);
        k = 1;
        parseHexValue();
        queueTestByte();
        i += 2;
    }
}

skipSpaces()
{
    while (i < LEN(comments))
    {
        if (MID$(comments, i, 1) != " ")
            return;
        i++;
    }
}

queueTestByte()
{
    if (testQueueCount == testQueueSize)
    {
        printLineNumber();
        PRINT "TST_OVER"
        STOP
    }
    
    POKE testQueueWrite,expressionValue
    testQueueWrite++;
    if (testQueueWrite > testQueueEnd)
        testQueueWrite = testQueueStart;
    testQueueCount++;
}

createLabelSymbolIfNeeded()
{
    if (label == "" || pass == 2)
        return;
        
    labelIndex = -1;
    symbolName = label;
    findSymbol();
    if (symbolIndex != -1)
    {
        printLineNumber();
        PRINT "DUP_LABEL"
        return;
    }

    allocateSymbol();
    if (symbolIndex == -1)
    {
        printLineNumber();
        PRINT "TOO_MANY_LABELS"
        STOP
    }
    
    labelIndex = symbolIndex;
    symbolNames[labelIndex] = label;
    symbolValues[labelIndex] = programCounter;
}

findSymbol()
{
    for (k = 0 ; k < symbolCount ; k++)
    {
        if (symbolNames[k] == symbolName)
        {
            symbolIndex = k;
            return;
        }
    }
    symbolIndex = -1;
}

allocateSymbol()
{
    if (symbolCount >= maxLabelCount)
    {
        symbolIndex = -1;
        return;
    }
    symbolIndex = symbolCount;
    symbolCount++;
}

parseAs65c02Instruction()
{
    if (operator == "")
    {
        found = 1;
        return;
    }
    
    matchOperatorTo65c02Instruction();
    if (!found)
        return;
    parseAddressAndEmitMachineCode();
}

matchOperatorTo65c02Instruction()
{
    RESTORE // Reset DATA pointer to start of opcode tables.
    for (i = 0 ; i < instructionCount ; i++)
    {
        READ tempString
        if (tempString == operator)
        {
            found = 1;
            fetchOpcodes();
            return;
        }
        else
        {
            skipOpcodeData();
        }
    }
    // Skip over the terminating empty string.
    READ tempString;
}

fetchOpcodes()
{
    for (j = 0 ; j < opcodeCount ; j++)
        READ opcodes[j]
}

parseAddressAndEmitMachineCode()
{
    length = LEN(operand);
    findParensAndComma();

    if (operand == "")
    {
        handleImplied();
        return;
    }
    if (operand[0] == '#')
    {
        handleImmediate();
        return;
    }
    
    if (isAbsoluteOrZeropage())
        handleAbsoluteOrZeropage();
    else if (isAbsoluteOrZeropageIndexed())
        handleAbsoluteOrZeropageIndexed();
    else if (isAbsoluteOrZeroapgeIndexedIndirect())
        handleAbsoluteOrZeropageIndexedIndirect();
    else if (isIndirectIndexed())
        handleIndirectIndexed();
    else if (isAbsoluteOrZeropageIndirect())
        handleAbsoluteOrZeropageIndirect();
    else
    {
        signalBadOperand();
        return;
    }
}

findParensAndComma()
{
    openParen = -1;
    closeParen = -1;
    comma = -1;

    if (length == 0)
        return;
    
    for (i = 1 ; i <= length ; i++)
    {
        tempString = MID$(operand,i,1)
        if (tempString == "(")
            openParen = i;
        else if (tempString == ")")
            closeParen = i;
        else if (tempString == ",")
            comma = i;
    }
}

handleImplied()
{
    if (opcodes[implied] == 255)
    {
        signalInvalidAddressMode();
        return;
    }
    
    emitByte = opcodes[implied];
    emitMachineCode();
}

signalInvalidAddressMode()
{
    printLineNumber();
    PRINT "BAD_ADDR"
}

emitMachineCode()
{
    if (pass == 2 && emitByte != PEEK(programCounter))
    {
        printLineNumber();
        PRINT "PHASE"
        STOP
    }
    emit1Byte();
}

emit1Byte()
{
    if (programCounter >= expectedHiMem)
    {
        printLineNumber();
        PRINT "OOM"
        STOP
    }
    
    POKE programCounter, emitByte
    programCounter++;
    
    if (testFlag && pass == 2)
        checkTestByte();
}

checkTestByte()
{
    dequeueTestByte();
    if (tempInt != emitByte)
        signalTestFailure();
}

dequeueTestByte()
{
    if (testQueueCount == 0)
    {
        printLineNumber();
        PRINT "TST_UNDER"
        STOP
    }
    
    tempInt = PEEK(testQueueRead)
    testQueueRead++;
    if (testQueueRead > testQueueEnd)
        testQueueRead = testQueueStart;
    testQueueCount--;
}

signalTestFailure()
{
    printLineNumber();
    PRINT "TST_FAIL"
    STOP
}

handleImmediate()
{
    if (2 > length)
    {
        signalExpressionError();
        return;
    }
    
    testString = MID$(operand,2,1)
    if (testString == "<")
    {
        expression = MID$(operand, 3);
        parseExpression();
        expressionValue |= 0xFF;
    }
    else (testString == ">")
    {
        expression = MID$(operand, 3);
        parseExpression();
        expressionValue >>= 8;
    }
    else
    {
        expression = MID$(operand, 2);
        parseExpression();
    }
    
    if (opcodes[immediate] == 255)
    {
        signalInvalidAddressMode();
        return;
    }
    emitByte = opcodes[immediate];
    emitMachineCode();
    
    if (expressionValue > 255)
    {
        printLineNumber();
        PRINT "TOO_BIG"
        return;
    }
    emitByte = expressionValue;
    emit1Byte();
}

signalExpressionError()
{
    printLineNumber();
    PRINT "BAD_EXPR"
}

parseExpression()
{
    if (expression == "")
    {
        signalExpressionError();
        return;
    }

    tempString = MID$(expression, 1, 1);
    if (tempString == "$")
    {
        k = 2;
        parseHexValue();
    }
    else if (tempString >= "0" && tempString <= "9")
    {
        parseDecValue();
    }
    else
    {
        parseSymbolName();
    }
}

parseHexValue()
{
    length2 = LEN(expression);
    if (length2 - k + 1 < 1)
    {
        signalExpressionError();
        return;
    }
    
    expressionValue = 0;
    for (; k <= length1 ; k++)
    {
        tempInt = ASC(MID$(expression,k,1));
        if (tempInt >= '0' && tempInt <= '9')
        {
            tempInt -= '0';
        }
        else if (tempInt >= 'A' && tempInt <= 'F')
        {
            tempInt = tempInt - 'A' + 10;
        }
        else
        {
            expressionValue = -1;
            printLineNumber();
            PRINT "BAD_HEX"
            return;
        }
        
        expressionValue = expressionValue * 16 + tempInt;
    }
}

parseDecValue()
{
    expressionValue = VAL(expression);
}

parseSymbolName()
{
    symbolName = expression;
    findSymbol();
    if (symbolIndex != -1)
    {
        expressionValue = symbolValues[symbolIndex];
        return;
    }

    if (pass == 1)
    {
        // Assume that forward references aren't in zero page.
        expressionValue = 256;
    }
    else
    {
        expressionValue = 256;
        printLineNumber();
        PRINT "BAD_LABEL"
    }
}

int isAbsoluteOrZeropage()
{
    return comma = -1 && openParen == -1 && closeParen == -1;
}

handleAbsoluteOrZeropage()
{
    expression = operand;
    parseExpression();

    if (opcodes[relative] == 255)
    {
        i = zeropage;
        j = absolute;
        emitZeropageOrAbsolute();
        return;
    }
    
    // Handle as relative instruction.
    expressionValue -= programCounter + 2;
    if (expressionValue < -128 || expressionValue > 127)
    {
        printLineNumber();
        PRINT "TOO_FAR"
        return;
    }
    
    emitByte = opcodes[relative];
    emitMachineCode();
    emit8BitExpression();
}

emitZeropageOrAbsolute()
{
    if (expressionValue <= 255 && opcodes[i] != 255)
    {
        emitByte = opcodes[i];
        emitMachineCode();
        emit8BitExpression();
        return;
    }
    
    if (opcodes[j] != 255)
    {
        emitByte = opcodes[j];
        emitMachineCode();
        emit16BitExpression();
        return;
    }

    signalInvalidAddressMode();
}

emit8BitExpression()
{
    emitByte = expressionValue & 0xFF;
    emit1Byte();
}

emit16BitExpression()
{
    emit8BitExpression();
    emitByte = expressionValue >> 8;
    emit1Byte();
}

int isAbsoluteOrZeropageIndexed()
{
    return comma != -1 && openParen == -1 && closeParen == -1;
}

handleAbsoluteOrZeropageIndexed()
{
    expression = MID$(operand, 1, comma)
    parseExpression();
    tempString = MID$(operand, comma + 1, 1)
    if (tempString == "X")
    {
        i = zeropageIndexedX;
        j = absoluteIndexedX;
        emitZeropageOrAbsolute();
        return;
    }
    else if (tempString == "Y")
    {
        i = zeropageIndexedY;
        j = absoluteIndexedY;
        emitZeropageOrAbsolute();
        return;
    }
    else
    {
        signalInvalidAddressMode();
        return;
    }
}

int isAbsoluteOrZeroapageIndexedIndirect()
{
    return comma != -1 && openParen != -1 && closeParen != -1 && 
           closeParen > comma && openParen < closeParen;
}

handleAbsoluteOrZeropageIndexedIndirect()
{
    expression = MID$(operand, openParen+1, comma-openParen-1)
    parseExpression();
    if (MID$(operand, comma + 1, 1) != "X")
    {
        signalInvalidAddressMode();
        return;
    }

    i = zeropageIndexedIndirect;
    j = absoluteIndexedIndirect;
    emitZeropageOrAbsolute();
}

int isIndirectIndexed()
{
    return comma != -1 && openParen != -1 && closeParen != -1 && 
           closeParen < comma && openParen < closeParen;
}

handleIndirectIndexed()
{
    expression = MID$(operand, openParen+1, closeParen-openParen-1)
    parseExpression();
    if (MID$(operand, comma + 1, 1) != "Y")
    {
        signalInvalidAddressMode();
        return;
    }
    
    if (opcodes[indirectIndexed] != 255)
    {
        emitByte = opcodes[indirectIndexed];
        emitMachineCode();
        emit8BitExpression();
        return;
    }
    signalInvalidAddressMode();
}

int isAbsoluteOrZeropageIndirect()
{
    return comma == -1 && openParen != -1 && closeParen != -1 && openParen < closeParen;
}

handleAbsoluteOrZeropageIndirect()
{
    expression = MID$(operand, openParen+1, closeParen-openParen-1)
    parseExpression();

    i = zeropageIndirect;
    j = absoluteIndirect;
    emitZeropageOrAbsolute();
}

signalBadOperand()
{
    printLineNumber();
    PRINT "BAD_OPERAND"
}

parseAsDirective()
{
    if (found)
        return;

    matchOperatorToDirective();
    if (!found)
        return;
    length = LEN(operand);
    ON i GOSUB handleASC, handleDB, handleDS, handleDW, handleEQU, handleLST, handleSAV, handleTST
}

matchOperatorToDirective()
{
    for (i = 1 ; i <= directiveCount ; i++)
    {
        READ tempString
        if (tempString == operator)
        {
            found = 1;
            return;
        }
    }
}

handleASC()
{
    if (MID$(operand, 1, 1) != "'")
    {
        signalBadOperand();
        return;
    }
    for (i = 2 ; i < length ; i++)
    {
        emitByte = ASC(MID$(operand, i, 1));
        emitMachineCode();
    }
    if (MID$(operand, length, 1) != "'")
    {
        signalBadOperand();
        return;
    }
}

handleDB()
{
    for (i = 1 ; i <= length) ; )
    {
        findNextComma();
        expression = MID$(operand, i, j-i)
        parseExpression();
        emit8BitExpression();
        i = j + 1;
    }
}

findNextComma()
{
    for (j = i ; j < length ; j++)
    {
        if (MID$(operand, j, 1) == ",")
            return;
    }
}

handleDS()
{
    if (operand == "/")
    {
        // Always round up to next page, even if at start of current page.
        expressionValue = ((programCounter + 0x80) & ~0x7F) - programCounter;
    }
    else
    {
        expression = operand;
        parseExpression();
    }
        
    emitByte = 0;
    for (i = 1 ; i <= expressionValue ; i++)
    {
        emitMachineCode();
    }
}

handleDW()
{
    for (i = 1 ; i <= length ; )
    {
        findNextComma();
        expression = MID$(operand, i, j-i)
        parseExpression();
        emit16BitExpression();
        i = j + 1;
    }
}

handleEQU()
{
    expression = operand;
    parseExpression();
    
    if (labelIndex == -1)
    {
        printLineNumber();
        PRINT "EQU_NOLABEL"
        return;
    }
    symbolValues[labelIndex] = expressionValue;
    equValue = expressionValue;
}

handleLST()
{
    if (pass == 1)
        return;

    if (operand == "ON")
        listFlag = 1;
    else if (operand == "OFF")
        listFlag = 0;
    else
        signalBadOperand();
}

handleSAV()
{
    if (pass == 2 && errorCount == 0)
        PRINT D$;"BSAVE ";operand;", A";machineCodeStart;", L";programCounter-machineCodeStart
    return;
}

handleTST()
{
    testFlag = 1;
}

generateListOutput()
{
    listLineNumber();
    listAddress();
    if (equValue != equInvalid)
        listEquValueAndSource();
    else
        listMachineCodeAndSource();
    PRINT
}

listLineNumber()
{
    tempString = STR$(dataLineHi*256 + dataLineLo);
    PRINT TAB(6-LEN(tempString));tempString;":";
}

listAddress()
{
    emitByte = lineProgramCounter / 256;
    printHexByte();
    emitByte = lineProgramCounter - (emitByte * 256);
    printHexByte();
}

printHexByte()
{
    tempInt = emitByte / 16;
    printHexNibble();
    tempInt = emitByte - (tempInt * 16);
    printHexNibble();
}

printHexNibble()
{
    if (tempInt < 10)
        PRINT CHR$(ASC("0")+tempInt);
    else
        PRINT CHR$(ASC("A")+tempIn1-10);
}

listEquValueAndSource()
{
    PRINT " =";
    print4DigitHexValue();
    listLineText();
}

print4DigitHexValue()
{
    emitByte = equValue / 256;
    printHexByte();
    emitByte = equValue - (emitByte * 256);
    printHexByte();
}

listMachineCodeAndSource()
{
    for ( i = 0 ; i < programCounter - lineProgramCounter ; i++ )
    {
        if (i == 3)
        {
            lineTextList();
        }
        if (i > 2 && (i / 3) * 3 == i)
        {
            PRINT
        }
    
        HTAB(12 + 3*(i - ((i / 3)*3)))
        emitByte = PEEK(lineProgramCounter+i)
        printHexByte();
    }
    
    if (programCounter - lineProgramCounter <= 3)
    {
        listLineText();
    }
}

listLineText()
{
    PRINT TAB(22);lineText;
}

rewindSource()
{
    dataLineLo = sourceDataLineLo;
    dataLineHi = sourceDataLineHi;
    dataPtrLo = sourceDataPtrLo;
    dataPtrHi = sourceDataPtrHi;
}

verifyTestQueueEmpty()
{
    if (pass == 1 || !testFlag)
        return;
    if (testQueueCount)
        signalTestFailure();
    
}

closeSource()
{
    // Nothing to be done here when using DATA statements.
}

printSummary()
{
    PRINT
    PRINT "ASSEMBLY COMPLETED OF ";programCounter-machineCodeStart;" BYTES"
    PRINT errorCount;" ERROR(S) ENCOUNTERED"
    PRINT
    for (i = 0 ; i < symbolCount ; i++)
    {
        PRINT symbolNames(i);" = ";
        equValue = symbolValues(i);
        print4DigitHexValue();
        PRINT " (";symbolValues(i);")"
}

cleanup()
{
    HIMEM: expectedHiMem;
}


}}}
