== Pseudo Code
What follows is the current pseudo code for my simple 6502 assembler.  It is a work in progress!


{{{
// Constants
const uint16_t expectedHiMem = 0x9600;      // DOS should be located above this address.
const uint16_t machineCodeStart = 0x7600;   // Assembled program will start at this address.
const uint16_t maxMachineCodeSize = expectedHiMem - machineCodeStart;   // Must be multiple of 256 bytes (a page).
const int16_t  opcodeCount = 14;            // The opcode table supports 14 addressing modes.
const int16_t  maxLabelCount = 256;         // The maximum number of labels to support.
const int16_t  testQueueStart = 0x300;      // Place unit test bytes in page 3.
const int16_t  testQueueEnd = 0x3FF;
const int16_t  testQueueSize = testQueueEnd - testQueueStart + 1;
const uint16_t equInvalid = 0x10000;
const int16_t  immediate = 0;
const int16_t  absolute = 1;
const int16_t  zeropage = 2;
const int16_t  implied = 3;
const int16_t  zeropageIndexedIndirect = 4;
const int16_t  indirectIndexed = 5;
const int16_t  zeropageIndexedX = 6;
const int16_t  zeropageIndexedY = 7;
const int16_t  absoluteIndexedX = 8;
const int16_t  absoluteIndexedY = 9;
const int16_t  relative = 10;
const int16_t  absoluteIndirect = 11;
const int16_t  absoluteIndexedIndirect = 12;
const int16_t  zeropageIndexedIndirect = 13;

// Globals
uint16_t programCounter;
uint16_t lineProgramCounter;
uint16_t equValue;

int16_t  listFlag;
int16_t  testFlag;
int16_t  instructionCount;
int16_t  directiveCount;
int16_t  pass;
int16_t  found;
int16_t  expressionValue;
int16_t  dataLineLo;
int16_t  dataLineHi;
int16_t  dataPtrLo;
int16_t  dataPtrHi;
int16_t  sourceDataLineLo;
int16_t  sourceDataLineHi;
int16_t  sourceDataPtrLo;
int16_t  sourceDataPtrHi;
int16_t  labelIndex;
int16_t  symbolIndex;
int16_t  symbolCount;
int16_t  testQueueWrite;
int16_t  testQueueRead;
int16_t  testQueueCount;
int16_t  openParen;
int16_t  closeParen;
int16_t  comma;
int16_t  emitByte;
int16_t  zeropageIndex;
int16_t  absoluteIndex;
int16_t  i;
int16_t  j;
int16_t  tempInt1;
int16_t  retInt1;
int16_t  retInt2;

string   D$;
string   lineText;
string   label;
string   operator;
string   operand;
string   comments;
string   symbolName;
string   expression;
string   tempString1;
string   tempString2;

int16_t  opcodes[];
int16_t  symbolValues[];
string   symbolNames[];


main()
{
    init();
    openSource();
    pass = 1;
    runPass();
    rewindSource();
    pass = 2;
    runPass();
    closeSource();
    cleanup();
}

init()
{
    CLEAR   // Tell BASIC to discard all variables.
    reserveMemoryForMachineCode();
    initVariables();
    initArrays();
    countOpcodeTableEntries();
    saveSourceDataLocations();
    SPEED=255 // Make listing output as fast as possible.
    TEXT      // Make sure that we are in text mode.
    PRINT: PRINT D$;"PR#3" : HOME // Switch to 80 Column Mode.
    PRINT "ASSEMBLY STARTED" // Includes newline to prepare for upcoming DOS calls.
}

reserveMemoryForMachineCode()
{
    if (getHIMEM() != expectedHiMem)
    {
        PRINT "*HIMEM"
        STOP
    }
    
    if (getEndOfVariablePointer() >= machineCodeStart)
    {
        PRINT "*NORAM"
        STOP
    }
    
    HIMEM: = machineCodeStart;
}

uint16_t getHIMEM()
{
    return (PEEK(0x74) << 8) | PEEK(0x73);
}

uint16_t getEndOfVariablePointer()
{
    return (PEEK(0x6E) << 8) | PEEK(0x6D);
}

initVariables()
{
    // Initialize floats.
    programCounter = 0;
    lineProgramCounter = 0;
    equValue = equInvalid;

    // Initialize integers.
    listFlag = 1;
    testFlag = 0;
    instructionCount = -1;
    directiveCount = -1;
    pass = 0;
    found = 0;
    dataLineLo = 0;
    dataLineHi = 0;
    dataPtrLo = 0;
    dataPtrHi = 0;
    sourceDataLineLo;
    sourceDataLineHi;
    sourceDataPtrLo;
    sourceDataPtrHi;
    labelIndex = -1;
    symbolIndex = -1;
    symbolCount = 0;
    testQueueWrite = testQueueStart;
    testQueueRead = testQueueStart;
    testQueueCount = 0;
    openParen = -1;
    closeParen = -1;
    comma = -1;
    emitByte = -1;
    i = 0;
    j = 0;
    tempInt1 = 0;
    retInt1 = 0;
    retInt2 = 0;
    
    // Initialize strings.
    D$ = CHRS(4);
    lineText = "";
    label = "";
    operator = "";
    operand = "";
    comments = "";
    symbolName = "";
    expression = "";
    tempString1 = "";
    tempString2 = "";
}

initArrays()
{
    DIM opcodes(opcodeCount-1)
    DIM symbolNames(maxLabelCount-1)
    DIM symbolValues(maxLabelCount-1)
}

// Example DATA statements for instruction opcode table.
// The first column is the mnemonic for the instruction.
// The rest of the columns are opcode value for the different addressing modes.
// The column order matches the table in the Apple IIe Technical Reference Manual.
// A value of 255 means that this addressing mode isn't supported for this instruction.
DATA "ADC", 105, 109, 101, 255, 97, 113, 117, 255, 125, 121, 255, 255, 255, 114
DATA "" // Terminates the table.

// Example DATA statements for directive table.
DATA "ASC", "DB", "DS", "DW", "EQU", "LST", "SAV", "TST"
DATA "" // Terminates the table.

// Example source code
DATA "LABEL BRA LABEL"
DATA "      SAV TEST.BIN"
DATA "      END"

countOpcodeTableEntries()
{
    for (;;)
    {
        READ tempString1
        if (tempString1 == "")
            break;
        instructionCount++;
        skipOpcodeData();
    }
    for (;;)
    {
        READ tempString1
        if (tempString1 == "")
            break;
        directiveCount++;
    }
    
    PRINT D$;"FRE(0)" // Free unused strings.
}

skipOpcodeData()
{
    for (i = 0 ; i < opcodeCount ; i++)
        READ tempInt1
}

saveSourceDataLocations()
{
    getCurrentDataLocations();
    sourceDataLineLo = dataLineLo;
    sourceDataLineHi = dataLineHi;
    sourceDataPtrLo = dataPtrLo;
    sourceDataPtrHi = dataPtrHi;
}

getCurrentDataLocations()
{
    dataLineLo = PEEK(0x7B);
    dataLineHi = PEEK(0x7C);
    dataPtrLo = PEEK(0x7D);
    dataPtrHi = PEEK(0x7E);
}

openSource()
{
    // Nothing to be done here as DATA pointer is already set and ready to read assembly source.
}

runPass()
{
    programCounter = machineCodeStart;
    for (;;)
    {
        fetchAndSplitNextLine();
        if (label != "" || operator != "")
        {
            if (operator == "END")
                break;
            parseLine();
        }
    }
}

fetchAndSplitNextLine()
{
    freeUnneededStrings();
    
    restoreDataLocations();
    READ lineText
    getCurrentDataLocations();
    
    lineProgramCounter = programCounter;
    equValue = equInvalid;
    
    i = 0;
    extractNextField();
    if (retInt1)
        return;
    label = tempString2;
        
    extractNextField();
    if (retInt1)
        return;
    operator = tempString2;

    extractNextField();
    if (retInt1)
        return;
    operand = tempString2;

    extractNextField();
    if (!retInt1)
    {
        printLineNumber();
        PRINT "*EXTRAINPUT"
    }
}

freeUnneededStrings()
{
    tempString1 = "";
    tempString2 = "";
    lineText = "";
    label = "";
    opcode = "";
    operand = "";
    comment = "";
    symbolName = "";
    PRINT D$;"FRE(0)" // Free unused strings.
}

restoreDataLocations()
{
    POKE 0x7B, dataLineLo
    POKE 0x7C, dataLineHi
    POKE 0x7D, dataPtrLo
    POKE 0x7E, dataPtrHi
}

extractNextField()
{
    // Just return if we have already extracted all of the fields already.
    if (i == LEN(lineText))
    {
        retInt1 = 1;
        return;
    }
    
    // Check for comment.
    if (lineText[i] == ';')
    {
        comment = MID$(lineText, i);
        retInt1 = 1;
        return;
    }
    
    // Not comment so extract field.
    findNextWhitespace();
    tempString2 = MID$(lineText, i, j-i);
    i = j;
    
    // Advance to start of next field.
    findNextNonWhitespace();
    i = j;
    
    retInt1 = 0;
    return;
}

findNextWhitespace()
{
    j = i;
    while (j < LEN(lineText))
    {
        if (lineText[j] == ' ')
            return;
        j++;
    }
}

findNextNonWhitespace()
{
    j = i;
    while (j < LEN(lineText))
    {
        if (lineText[j] != ' ')
            return;
        j++;
    }
}

printLineNumber()
{
    PRINT "LINE:"; dataLineHi*256 + dataLineLo ; " ";
}

parseLine()
{
    if (testFlag)
        parseCommentForTestBytes();
    createLabelSymbolIfNeeded();
    found = 0;
    parseAs65c02Instruction();
    parseAsDirective();
    if (!found)
    {
        printLineNumber();
        PRINT "*INVALID_OPCODE"
    }
    if (listFlag)
        generateListOutput();
}

parseCommentForTestBytes()
{
    doesCommentContainTestData();
    if (!retInt1)
        return;
    queueUpTestBytes();
}

doesCommentContainTestData()
{
    for (i = 0 ; i < LEN(comment) ; i++)
    {
        j = ASC(MID$(comment, i, 1))
        if (j != ASC(" ") && j < ASC("0") && j > ASC("9") && j < ASC("A") && j > ASC("F"))
        {
            retInt = 0;
            return;
        }
    }
    retInt = 1;
}

queueUpTestBytes()
{
    i = 0;
    while (i < LEN(comment))
    {
        skipSpaces();
        expression = MID$(comment, i, 2);
        parseHexValue();
        queueTestByte();
        i += 2;
    }
}

skipSpaces()
{
    while (i < LEN(comment))
    {
        if (comment[i] != ' ')
            return;
        i++;
    }
}

queueTestByte()
{
    if (testQueueCount == testQueueSize)
    {
        printLineNumber();
        PRINT "*TST_OVER"
        STOP
    }
    
    POKE testQueueWrite,expressionValue
    testQueueWrite++;
    if (testQueueWrite > testQueueEnd)
        testQueueWrite = testQueueStart;
    testQueueCount++;
}

createLabelSymbolIfNeeded()
{
    if (label == "" || pass == 2)
        return;
        
    labelIndex = -1;
    symbolName = label;
    findSymbol();
    if (symbolIndex != -1)
    {
        printLineNumber();
        PRINT "*LABEL_EXISTS"
        return;
    }

    allocateSymbol();
    if (symbolIndex == -1)
    {
        printLineNumber();
        PRINT "*TOO_MANY_LABELS"
        STOP
    }
    
    labelIndex = symbolIndex;
    symbolNames[labelIndex] = label;
    symbolValues[labelIndex] = programCounter;
}

findSymbol()
{
    for (symbolIndex = 0 ; symbolIndex < symbolCount ; symbolIndex++)
    {
        if (symbolNames[symbolIndex] == symbolName)
            return;
    }
    symbolIndex = -1;
}

allocateSymbol()
{
    if (symbolCount >= maxLabelCount)
    {
        symbolIndex = -1;
        return;
    }
    symbolIndex = symbolCount;
    symbolCount++;
}

parseAs65c02Instruction()
{
    if (operator == "")
    {
        found = 1;
        return;
    }
    
    matchOperatorTo65c02Instruction();
    if (!found)
        return;
    parseAddressAndEmitMachineCode();
}

matchOperatorTo65c02Instruction()
{
    RESTORE // Reset DATA pointer to start of opcode tables.
    for (i = 0 ; i < instructionCount ; i++)
    {
        READ tempString1
        if (tempString1 == operator)
        {
            found = 1;
            fetchOpcodes();
        }
        else
        {
            skipOpcodeData();
        }
    }
}

fetchOpcodes()
{
    for (j = 0 ; j < opcodeCount ; j++)
        READ opcodes[j]
}

parseAddressAndEmitMachineCode()
{
    findParensAndComma();

    if (operand == "")
        handleImplied();
    else if (operand[i] == '#')
        handleImmediate();
    else if (isAbsoluteOrZeropage())
        handleAbsoluteOrZeropage();
    else if (isAbsoluteOrZeropageIndexed())
        handleAbsoluteOrZeropageIndexed();
    else if (isAbsoluteOrZeroapgeIndexedIndirect())
        handleAbsoluteOrZeropageIndexedIndirect();
    else if (isIndirectIndexed())
        handleIndirectIndexed();
    else if (isAbsoluteOrZeropageIndirect())
        handleAbsoluteOrZeropageIndirect();
    else
    {
        signalBadOperand();
        return;
    }
}

findParensAndComma()
{
    openParen = -1;
    closeParen = -1;
    comma = -1;
    
    for (i = 0 ; i < LEN(operand) ; i++)
    {
        if (operand[i] == '(')
            openParen = i;
        else if (operand[i] == ')')
            closeParen = i;
        else if (operand[i] == ',')
            comma = i;
    }
}

handleImplied()
{
    if (opcodes[implied] == 255)
    {
        signalInvalidAddressMode();
        return;
    }
    
    emitByte = opcodes[implied];
    emitMachineCode();
}

signalInvalidAddressMode()
{
    printLineNumber();
    PRINT "*BAD_ADDR"
}

emitMachineCode()
{
    if (pass == 2 && emitByte != PEEK(programCounter))
    {
        printLineNumber();
        PRINT "*PHASE"
        STOP
    }
    emit1Byte();
}

emit1Byte()
{
    if (programCounter >= expectedHiMem)
    {
        printLineNumber();
        PRINT "*OOM"
        STOP
    }
    
    POKE programCounter, emitByte
    programCounter++;
    
    if (testFlag)
        checkTestBytes();
}

checkTestBytes()
{
    dequeueTestByte();
    if (tempInt1 != emitByte)
    {
        printLineNumber();
        PRINT "*TST_FAIL"
        STOP
    }
}

dequeueTestByte()
{
    if (testQueueCount == 0)
    {
        printLineNumber();
        PRINT "*TST_UNDER"
        STOP
    }
    
    tempInt1 = PEEK(testQueueRead)
    testQueueRead++;
    if (testQueueRead > testQueueEnd)
        testQueueRead = testQueueStart;
    testQueueCount--;
}

handleImmediate()
{
    i = 1;
    checkOperandLength();
    if (retInt1 = -1)
        return;
    
    if (operand[i] == '<')
    {
        expression = MID$(operand, 2);
        parseExpression();
        expressionValue |= 0xFF;
    }
    else (operand[i] == '>')
    {
        expression = MID$(operand, 2);
        parseExpression();
        expressionValue >>= 8;
    }
    else
    {
        expression = MID$(operand, 1);
        parseExpression();
    }
    
    if (opcodes[immediate] == 255)
    {
        signalInvalidAddressMode();
        return;
    }
    emitByte = opcodes[immediate];
    emitMachineCode();
    
    if (expressionValue > 255)
    {
        printLineNumber();
        PRINT "*TOO_BIG"
        return;
    }
    emitByte = expressionValue;
    emit1Byte();
}

checkOperandLength()
{
    retInt = 0;
    if (i >= LEN(operands))
        signalExpressionError();
}

signalExpressionError()
{
    retInt = -1;
    printLineNumber();
    PRINT "*BAD_EXPR"
}

parseExpression()
{
    if (expression == "")
    {
        signalExpressionError();
        return;
    }

    if (expression[0] == '$')
    {
        parseHexValue();
    }
    else if (expression[0] >= '0' && expression[0] <= '9')
    {
        parseDecValue();
    }
    else
    {
        parseSymbolName();
    }
}

parseHexValue()
{
    if (LEN(expression) < 2)
    {
        signalExpressionError();
        return;
    }
    
    expressionValue = 0;
    for (i = 1 && i < LEN(expression) && i++)
    {
        tempInt1 = ASC(expression[i]);
        if (tempInt1 >= '0' && tempInt1 <= '9')
        {
            tempInt1 -= '0';
        }
        else if (tempInt1 >= 'A' && tempInt1 <= 'F')
        {
            tempInt1 = tempInt1 - 'A' + 10;
        }
        else
        {
            expressionValue = -1;
            printLineNumber();
            PRINT "*BAD_HEX"
            return;
        }
        
        expressionValue = expressionValue * 16 + tempInt1;
    }
}

parseDecValue()
{
    expressionValue = VAL(MID$(expression, 0));
}

parseSymbolName()
{
    symbolName = MID$(expression, 0);
    findSymbol();
    if (symbolIndex == -1)
    {
        if (pass == 1)
        {
            // Assume that forward references aren't in zero page.
            expressionValue = 257;
        }
        else
        {
            expressionValue = -1;
            printLineNumber();
            PRINT "*BAD_LABEL"
        }
        return;
    }
    
    expressionValue = symbolValues[symbolIndex];
}

isAbsoluteOrZeropage()
{
    return comma = -1 && openParen == -1 && closeParen == -1;
}

handleAbsoluteOrZeropage()
{
    parseExpression();

    i = zeropage;
    j = absolute;
    emitZeropageOrAbsolute();
    
    if (expressionValue <= 255 && opcodes[zeropage] != 255)
    {
        emitByte = opcodes[zeropage];
        emitMachineCode();
        emit8BitValue();
        return;
    }
    
    if (opcodes[absolute] != 255)
    {
        emitByte = opcodes[absolute];
        emitMachineCode();
        emit16BitExpression();
        return;
    }
    
    if (opcodes[relative] != 255)
    {
        expressionValue -= programCounter;
        if (expressionValue < -128 || expressionValue > 127)
        {
            printLineNumber();
            PRINT "*TOO_FAR"
            return;
        }
        
        emitByte = opcodes[relative];
        emitMachineCode();
        emit8BitExpression();
        return;
    }
    
    signalInvalidAddressMode();
    return;
}

emitZeropageOrAbsolute()
{
    if (expressionValue <= 255 && opcodes[i] != 255)
    {
        emitByte = opcodes[i];
        emitMachineCode();
        emit8BitValue();
        return;
    }
    
    if (opcodes[j] != 255)
    {
        emitByte = opcodes[j];
        emitMachineCode();
        emit16BitExpression();
        return;
    }
}

emit8BitExpression()
{
    emitByte = expressionValue;
    emit1Byte();
}

emit16BitExpression()
{
    emitByte = expressionValue & 0xFF;
    emit1Byte();
    emitByte = expressionValue >> 8;
    emit1Byte();
}

isAbsoluteOrZeropageIndexed()
{
    return comma != -1 && openParen == -1 && closeParen == -1;
}

handleAbsoluteOrZeropageIndexed()
{
    expression = MID$(operand, 0, comma)
    parseExpression();
    if (MID$(comma + 1, 1) == "X")
    {
        i = zeropageIndexedX;
        j = absoluteIndexedX;
    }
    else if (MID$(comma + 1, 1) == "Y")
    {
        i = zeropageIndexedY;
        j = absoluteIndexedY;
    }
    else
    {
        signalInvalidAddressMode();
        return;
    }
    emitZeropageOrAbsolute();
}

isAbsoluteOrZeroapageIndexedIndirect()
{
    return comma != -1 && openParen != -1 && closeParen != -1 && 
           closeParen > comma && openParen < closeParen;
}

handleAbsoluteOrZeropageIndexedIndirect()
{
    expression = MID$(operand, openParen+1, comma-openParen-1)
    parseExpression();
    if (MID$(comma + 1, 1) != "X")
    {
        signalInvalidAddressMode();
        return;
    }

    i = zeropageIndexedIndirect;
    j = absoluteIndexedIndirect;
    emitZeropageOrAbsolute();
}

isIndirectIndexed()
{
    return comma != -1 && openParen != -1 && closeParen != -1 && 
           closeParen < comma && openParen < closeParen;
}

handleIndirectIndexed()
{
    expression = MID$(operand, openParen+1, closeParen-openParen-1)
    parseExpression();
    if (MID$(comma + 1, 1) != "Y")
    {
        signalInvalidAddressMode();
        return;
    }
    
    if (opcodes[zeropageIndirectIndexed] != 255)
    {
        emitByte = opcodes[zeropageIndirectIndexed];
        emitMachineCode();
        emit8BitValue();
        return;
    }
}

isAbsoluteOrZeropageIndirect()
{
    return comma == -1 && openParen != -1 && closeParen != -1 && openParen < closeParen;
}

handleAbsoluteOrZeropageIndirect()
{
    expression = MID$(operand, openParen+1, closeParen-openParen-1)
    parseExpression();

    i = zeropageIndirect;
    j = absoluteIndirect;
    emitZeropageOrAbsolute();
}

signalBadOperand()
{
    printLineNumber();
    PRINT "*BAD_OPERAND"
}

parseAsDirective()
{
    if (found)
        return;

    matchOperatorToDirective();
    if (!found)
        return;
    ON i GOSUB handleASC, handleDB, handleDS, handleDW, handleEQU, handleLST, handleSAV, handleTST
}

matchOperatorToDirective()
{
    for (i = 0 ; i < directiveCount ; i++)
    {
        READ tempString1
        if (tempString1 == operator)
        {
            found = 1;
            return;
        }
    }
}

handleASC()
{
    if (operand[0] != '\'')
    {
        signalBadOperand();
        return;
    }
    for (i = 0 ; i < LEN(operand) - 1 ; i++)
    {
        emitByte = ASC(operand[i]);
        emitMachineCodeByte();
    }
    if (operand[i] != '\'')
    {
        signalBadOperand();
        return;
    }
}

handleDB()
{
    for (i = 0 ; i < LEN(operand) ; )
    {
        findNextComma();
        expression = MID$(operand, i, j-i)
        parseExpression();
        emit8BitExpression();
        i = j + 1;
    }
}

findNextComma()
{
    for (j = i ; j < LEN(operand) ; j++)
    {
        if (operand[j] == ',')
            return;
    }
}

handleDS()
{
    if (operand == '/')
    {
        expressionValue = (programCounter + 0x7F) & ~0x7F;
    }
    else
    {
        expression = operand;
        parseExpression();
    }
        
    emitByte = 0;
    for (i = 0 ; i < expressionValue ; i++)
    {
        emit1Byte();
    }
}

handleDW()
{
    for (i = 0 ; i < LEN(operand) ; )
    {
        findNextComma();
        expression = MID$(operand, i, j-i)
        parseExpression();
        emit16BitExpression();
        i = j + 1;
    }
}

handleEQU()
{
    expression = operand;
    parseExpression();
    
    if (labelIndex == -1)
    {
        printLineNumber();
        PRINT "*EQU_NOLABEL"
        return;
    }
    symbolValues[labelIndex] = expressionValue;
    equValue = expressionValue;
}

handleLST()
{
    if (expression == "ON")
        listFlag = 1;
    else if (expression == "OFF")
        listFlag = 0;
    else
    {
        printLineNumber();
        PRINT "*BAD_OPERAND"
    }
}

handleSAV()
{
    PRINT D$;"BSAVE ";operand;" A=";machineCodeStart;" L=";programCounter-machineCodeStart
}

handleTST()
{
    testFlag = 1;
}

generateListOutput()
{
    listLineNumber();
    listAddress();
    if (equValue != equInvalid)
        listEquValueAndSource();
    else
        listMachineCodeAndSource();
    PRINT
}

listLineNumber()
{
    tempString1 = STR$(dataLineHi*256 + dataLineLo);
    PRINT TAB(5-LEN(tempString1));tempString1;": ";
}

listAddress()
{
    emitByte = lineProgramCounter / 256;
    printHexByte();
    emitByte = lineProgramCounter - (emitByte * 256);
    printHexByte();
}

printHexByte()
{
    tempInt1 = emitByte / 16;
    printHexNibble();
    tempInt1 = emitByte - (tempInt1 * 16);
    printHexNibble();
}

printHexNibble()
{
    if (tempInt1 < 10)
        PRINT CHR$(ASC("0")+tempInt1);
    else
        PRINT CHR$(ASC("A")+tempIn1-10);
}

listEquValue()
{
    PRINT " =";
    emitByte = equValue / 256;
    printHexByte();
    emitByte = equValue - (emitByte * 256);
    printHexByte();
    
    listLineText();
}

listMachineCodeAndSource()
{
    for ( i = 0 ; i < programCounter - lineProgramCounter ; i++ )
    {
        if (i == 3)
        {
            lineTextList();
        }
        if ((i / 3) * 3 == i)
        {
            PRINT
        }
    
        HTAB(11 + 3*(i - ((i / 3)*3)))
        printHexByte();
    }
    
    if (programCounter - lineProgramCounter > 3)
    {
        listLineText();
    }
}

listLineText()
{
    PRINT TAB(22);"  ";lineText;
}

rewindSource()
{
    dataLineLo = sourceDataLineLo;
    dataLineHi = sourceDataLineHi;
    dataPtrLo = sourceDataPtrLo;
    dataPtrHi = sourceDataPtrHi;
}

closeSource()
{
    // Nothing to be done here when using DATA statements.
}

cleanup()
{
    CLEAR   // Tell BASIC to discard all variables.
    HIMEM: = expectedHiMem;
}


}}}
