==Initial Challenge Goals Met
I have met my initial Retrochallenge 2013 goals and I am now working through revised goals for the rest of July.

[[https://github.com/adamgreen/Retrochallenge-2013SC#july-15th-2013---feature-complete-at-the-halfway-mark | Read more...]]


==July 17th, 2013 - J is No Longer Missing in Action

I took my Apple IIe apart last night to take a look at my J key issue.  I never figured out how to get access to the
switches but I did notice that the solder joint on the J key looked a bit dull so I reflowed it with my soldering iron. 

**BINGO**

I now have a working J key!  That will make typing in 65c02 instructions such as **JMP** and **JSR** much easier.


==July 16th, 2013 - Performance

I had previously mentioned that it was taking **3 minutes and 11 seconds** to assemble my simple 41 line HelloWorld
program.  I expected my initial Applesoft BASIC code to be slow but this is much worse than I expected.  There were
definitely some decisions that I made when writing the assembler that aren't best practices for Applesoft performance.
These include:

* **Extraneous use of GOSUB:**  I broke the program down into small units of functionality in the pseudocode so that
  each subroutine performs one task and one task only.  This makes it easier for me to read the code but creates the
  need for a lot of GOSUBs in the resulting BASIC code.  If a function is only called once then inlining it will make
  the program smaller and faster since there would be no need for the GOSUB call.  You would often be able to get rid of
  the RETURN call as well but in some cases, the RETURN would need to be replaced with a GOTO which isn't as fast.
* **Large line numbers:**  The main code starts at line 2000 and each subroutine starts on a line which is an even
multiple of 100.  This results in longer target line numbers for GOSUB and GOTO statements in the code.  Not only does
this make the code larger, it also makes the runtime parsing of the line numbers slower.
* **Subroutine order:**  The subroutines were translated to BASIC in the same order as they were found in the pseudo
code.  This order is about making it easier to read the pseudocode from top to bottom and cares nothing for performance.
The subroutines which are called the most often in BASIC should be given low line numbers so that the linear search
conducted by Applesoft for GOSUB calls will find them more quickly.
* **Variable order:**  No care was taken to order the initialization of variables in the BASIC code.  Like subroutines,
Applesoft performs a linear search to find variables when they are referenced by name in the code.  Variables used in
hot routines should be initialized early so that they are found sooner during the search.

===Poor Man's Profiler
One of the best rules for performance optimization is to only optimize the parts of the code where you are spending your
time.  So where is the assembler spending its time?  Profiling the code while it is assembling some 6502 code would be
nice.  How to most easily profile the code running on my actual Apple IIe hardware?  

I think the "Poor Man's Profiler" might be the right way to go here.  This profiling technique works just as well on
these old machines as it does on current ones.  On a current machine I would use a debugger as the
"Poor Man's Profiler".  Just break into the program a dozen or more times while the application is running and note the
call stacks that you obtain.  The most time consuming routines tend to bubble to the top of this list.  You can think of
this as a manual sampling profiler.  The same profiling approach can be done in Applesoft by pressing **CTRL+C** while
the program is running, noting the line number it stops on, and then issuing the **CONT** command to continue execution.
I did this several times in my assembler and the results were pretty close to what I expected:

|= Line Number |= Occurrences |= Routine |= Notes |= Percentage |
| 2500 | 7 | skipOpCodeData | Called from matchOperatorTo65c02Instruction | 70% |
| 4700 | 2 | matchOperatorTo65c02Instruction | | 20% |
| 3500 | 1 | findNextNonWhitespace | | 10% |

9/10ths of my hits were in the code used to lookup the operator string in the opcode table.  This code needs some
improvement!

===Binary is Better!
The matchOperatorTo65c02Instruction function actually does a linear search through the DATA statements that start at
line 1000 in the BASIC code.  I had suspected that this linear search was giving me problems as I watched the listing
output generation during unit test runs.  The lines towards the end of the listing were much slower to generate than the
earlier ones.   These lines were testing opcodes that were also at the end of the opcode table.  The worst performers
were the directives which actually caused the code to search through all of the opcode table to only fail finding a
match and then need to search through a separate directives table.

My initial opcode table was already in sorted in alphabetical order since that is how it was arranged in the source
table from the Apple IIe Technical Reference Manual.  This makes it an ideal candidate for a binary search.  I split the
work of enabling a binary search of this table into three parts:
* First I pulled the directives into the same table as the 65c02 instructions so that only one search needs to be
performed.  Whereas the 65c02 instruction entries contain 14 opcodes for the the different addressing modes, the
directives just have one which is set to 0.
* I implemented a new function called populateOpcodeTableEntries (line 10400 in BASIC) which is called during startup.
This function walks the sorted opcode table once to count the number of entries.  It uses this count to DIMension some
arrays and then walks the opcode table again to fill in these arrays.  One array is used to store the operator names for 
ach table entry.  The other arrays are used to store the DATA pointers for where the opcodes can be found in memory for
the corresponding operator.  In the case of directives, these pointers will just be set to a 0 based index to indicate
which directive of ASC, DB, DS, DW, EQU, LST, SAV, or TST the entry corresponds.
* I then reworked the runtime code which searches for an operator match in the table.  It now does a binary search on
the array of operator names.  If if gets a match for a directive then it can just pulls the directive index directly
from the corresponding DATA pointer array and returns.  In the case of 65c02 instructions, it reset the current DATA
pointer to the corresponding entry from the DATA pointer array, and then READs the 14 opcodes into the opcodes (O% in
BASIC) array before returning.

===Updating HELLO.BAS
Once I had made and tested the above mentioned performance improvements in the core SASM.BAS code, I wanted to try them
out with my HELLO.BAS program.  The easiest way to do this would be to delete the unit testing 65c02 source code lines
(32000-63999) from the SASM.BAS program and replace them with the sample 65c02 source code from HELLO.BAS.

Just to make sure that I didn't do something stupid, the first thing I did was lock the SASM.BAS file.
{{{
]LOCK SASM.BAS
}}}

I then loaded HELLO.BAS into memory and saved out the 65c02 source lines to a text file named CODE.TXT:
{{{
]LOAD HELLO.BAS
]30000 PRINT CHR$(4);"OPEN CODE.TXT":PRINT CHR$(4);"WRITE CODE.TXT":LIST 32000,:PRINT CHR$(4);"CLOSE CODE.TXT":END
]RUN 30000
}}}

Now I could just reload SASM.BAS, replaces its 65c02 source lines, and save out the result as HELLO.BAS:
{{{
]LOAD SASM.BAS
]DEL 32000,63999
]EXEC CODE.TXT
]SAVE HELLO.BAS
}}}

===Updated Performance Measurements
|= Original Run Time |= Current Run Time |= Improvement |
| 191 seconds | 76 seconds | 60% |

This is definitely a step in the right direction but there is still room for improvement!


==July 15th, 2013 - Feature Complete at the Halfway Mark

It is hard to believe that we are already half way through the month.   It is awe inspiring to look at all of the other
cool Retrochallenge projects progressing 
[[http://www.wickensonline.co.uk/retrochallenge-2012sc/2013/07/15/half-time-roundup/ | here]].  I don't stand a chance
against competition like that but at least I am having gobs of fun and learning tons about the Apple II.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130715-01.jpg}}

This weekend I finished the 65c02 opcode table.  The screenshot above shows a snippet of an actual HelloWorld sample
being assembled and the resulting binary executing successfully.  I did suppress some of the assembler output so that
everything would fit on the screen but the complete code listing follows:

{{{
32000  DATA "COUT    EQU $FDED"
32010  DATA "CR      EQU $FC62"
32020  DATA "        LDX #0"
32030  DATA "LOOP    LDA STR,X"
32040  DATA "        BEQ EXIT"
32050  DATA "        PHX"
32055  DATA "        ORA #$80"
32060  DATA "        JSR COUT"
32070  DATA "        PLX"
32080  DATA "        INX"
32090  DATA "        BRA LOOP"
32100  DATA "EXIT    JSR CR"
32110  DATA "        RTS"
32115  DATA "        LST OFF"
32120  DATA "STR     ASC 'HELLO RETROCHALLENGE 2013!'
32130  DATA "        DB 0"
32140  DATA "        SAV HELLO.BIN"
63999  DATA " END"
}}}

===Revisit My Initial Challenge Goals
* Have Fun.  **Check**
* Learn more about programming my Apple ][e. **Check**
* Write a simple 6502 assembler in AppleSoft BASIC. **Check**
* Actually write the code on my Apple ][e and only switch to an emulator if something should break on the real hardware
  during the challenge timeframe. **Check**
* Read 6502 assembly language source code from DATA statements appended to the end of the assembler program. **Check**
* Output human readable listing output to the screen as part of the assembly process. **Check**
* Output a BLOADable program to a ProDOS file. **Check**

I guess I didn't really challenge myself :) So...

===What's Next?
What should I do for the next 2+ weeks of the Retrochallenge?

Sleep?  Nah, sleep is optional and besides I can catch up on that in August, after the Challenge.

I can definitely think of a few more goals to append to my initial challenge list.

====Improve Assembly Performance
To say that my Applesoft code has resulted in a **slow** assembler would be an understatement!  It takes 3 minutes and
11 seconds to assemble that little HelloWorld sample seen above.  I definitely think there is some low hanging fruit
that I could pick to help in the area of performance.

====Make It Easier to Write Code with JSR and JMP Instructions
As I mentioned back during the first week of the challenge, the **J** key on the keyboard of my Apple IIe isn't working.
That makes it pretty hard to use 6502 instructions such as JSR and JMP.  I actually issue a {{{PRINT CHR$(74)}}} to have
Applesoft BASIC display a J character on the screen.  I then use the crude editing functionality in Applesoft to trace
my cursor over that printed J character whenever I need it for something like a JMP or JSR instruction.

Over the next two weeks I will take my Apple II apart in an attempt to fix this issue.

====Put the Assembler to Use
I definitely want to spend time through the rest of the month continuing to learn by actually using the assembler to
write some simple Apple II assembly language programs as I continue to read books like Gary B. Little's
"Inside the Apple IIe".

===Revised Challenge Goals

My revised challenge goals for the second half of July are therefore:

* Continue having fun.
* Continue learning more about programming my Apple ][e.
* Attempt to fix the **J** key on my Apple ][e keyboard.
* Write actual 6502 assembly language programs using my assembler.
* Improve performance of assembler enough to make previous goal tolerable.
* Actually write the code on my Apple ][e and only switch to an emulator if something should break on the real hardware
  during the challenge timeframe.


==July 11th, 2013 - Error Handling

Most of my work today was concentrated around error handling.  First I went through the code and documented all of the
error messages
[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/features.creole#error-messages | here in the assembler documentation]].
I also wrote several tests to force the assembler to generate these error messages so that I could verify and fix any
issues in the associated error handling code paths.

Additionally, I tested all of the valid and invalid addressing modes for the ADC instruction.  The next day or so will
be spent filling in the opcode table for all of the other 65c02 instructions.  Once that is done, the assembler will be
feature complete.

Diffs for today's commits:
* [[https://github.com/adamgreen/Retrochallenge-2013SC/commit/d0dbd1254dc4e6a7b8eed646ff169b51f0f8119d | Test all valid and invalid addressing modes for ADC]]
* [[https://github.com/adamgreen/Retrochallenge-2013SC/commit/57c36cf940ef5aacd81f38c72dfdeee4cf7190b1 | Added error text message descriptions]]
* [[https://github.com/adamgreen/Retrochallenge-2013SC/commit/157a7dfb09e233e602efec8108f1656aa2cd8935 | Test and improve error handling]]


==July 10th, 2013 - Testing and Debugging - Day 2

It's lucky that I wrote so many bugs into my code!  It keeps giving me something to work on :)

Diffs for today's commits:
* [[https://github.com/adamgreen/Retrochallenge-2013SC/commit/814744e319166fe25162b31faeb72824b72f4eb2 | Added tests for the rest of the directives]]
* [[https://github.com/adamgreen/Retrochallenge-2013SC/commit/f6d012060aeb03a1c30d0d0721fd406f3e257d89 | Print summary notes at end of assembly process]]


==July 9th, 2013 - Testing and Debugging

===TST Mode
One of the first things I did today was enable and fix the bugs in my unit testing functionality.  This code is enabled
by including a TST directive near the beginning of the assembly source.  Once this test mode is enabled, the comment
field is used to provide the expected values for the emitted machine code.  For example:
{{{
32000  DATA  " TST"
32005  DATA  "LABEL ADC #$20 ;69 20"
}}}
On line 32005, the {{{;69 20}}} comment indicates that the {{{ADC #$20}}} instruction is expected to emit two machine
code values and they are to have the values of **0x69** and **0x20**.  Refer to the 
[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/features.creole#tst | feature documentation for more information on the TST directive]].

===SAV Bug
I also tested out the LST and SAV directives and fixed bugs that I encountered.  I did hit an interesting bug in my
understanding of Applesoft BASIC and ProDOS today when testing out the SAV directive.  The SAV directive should have
taken the resulting machine code and saved it to disk as a binary file that is BRUNnable but the resulting binary file
just contained two bytes of 0 instead of the expected machine code of 0x69 and 0x20.

My code flow for creating machine code is roughly the following:
* reserveMemoryForMachineCode (line 2200 in BASIC) sets HIMEM: to 0x7600 instead of the initial 0x9600 set by ProDOS.
  This limits the highest address available to Applesoft BASIC so that it will allocate strings from just below this
  address.
* runPass (line 2900) initializes programCounter (P variable in BASIC code).
* emit1Byte (line 5400) will emit machine code to the address specified by programCounter and then increment that
  counter.  This causes the assembler to start emitting machine code to address 0x7600 and increment upwards in memory,
  making sure to not exceed into the 0x9600 region used by ProDOS.
* handleSAV (line 8600) issues a BSAVE command to ProDOS instructing it to save the 2 bytes of machine code starting at
  address 0x7600.

The fact that I was getting zeroes in the resulting binary file was weird to me based on these observations:
* The BSAVE command not only uses the supplied address to determine from where it should start the binary save, it also
places this address in the ProDOS directory entry so that future BLOADs will default to loading into the same address.
Running a CATALOG command should the following text for this file which indicates that the BSAVE was instructed to save
2 bytes from the correct address of 0x7600.
{{{
TEST.BIN        BIN       1  <NO DATE>        <NO DATE>              2 A=$7600
}}}
* I knew that the expected opcode value of 0x69 had been located in memory at some point because:
** The second pass of the assembler would have checked that the opcode byte matched between the two passes to make sure
   that there wasn't a phasing error.
** The second pass of the assembler had also successfully verified that this opcode byte was 0x69 because of the use of
   the TST directive to enable the test mode.
** When debugging previous issues in my code, I had actually PEEKed into the contents of memory at locations 0x7600 and
   0x7601 to find the expected values.

From here my next debugging step was to PEEK into the contents of 0x7600 and 0x7601 at the completion of the program
after I had REMarked out the code at line 9800 which would have reset HIMEM: back up to its original value of 0x9600.
What did I find?  Oddly enough I found that the two bytes did indeed just contain zeroes.  

I thought that maybe by allowing the code to run to completion, I had allowed some other code to run which zeroed it out
after the call to BSAVE.  To make sure that this wasn't happening, I added a STOP to the code immediately after the
BSAVE call had been made.  The result of this was the same zeroes.  

Based on my previous observations I was pretty sure that the bytes had been properly set when assembling the previous
source line.  To verify this I moved the STOP so that it occurred just before the BSAVE call was made.  PEEKing into
memory here showed the expected values of 0x69 and 0x20.  Letting the code to continue running, it made the call to
BSAVE and then STOPped again.  PEEKing at the bytes again here showed that the call to BSAVE itself had zeroed out my
machine code output.

Google to the rescue!  I typed "HIMEM ProDOS" into Google and the first result led to the 
[[http://macgui.com/usenet/?group=1&id=153171#msg | answer for my woes]].  The answer is in this quote from David Empson
on October 28th, 1998:
{{{
According to the ProDOS-8 technical reference, BASIC.SYSTEM uses the 1K
above HIMEM as its working buffer.  This means that you should reduce
HIMEM by the number of pages you need, but skip four pages to locate the
area you can use safely.
}}}
That explains why my machine code is getting overwritten since it is in the first 2 bytes of that 1K block used by
BASIC.SYSTEM.  I modified the assembler to start emitting machine code just after this 1K region and then the SAV worked
perfectly.  Problem solved!


==July 8th, 2013 - Successfully Assembled 1 Line of 6502 Code

I hit a relatively major milestone today when I finished implementing the first revision of my simple 65c02 assembler in
Applesoft BASIC and it successfully assembled its first line of 6502 assembly.  Yay!

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130708-01.jpg}}

Now I need to write a more extensive set of tests to exercise more of the code and smash the bugs that will no doubt
scurry out from within the dark recesses of my BASIC code :)

[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/7d9b4769ac6ebff1c522c3d17e89baa8e9c7316f/files/SASM.BAS | Browse initial Applesoft source code...]]


==July 7th, 2013 - Progressing....

This weekend, I started implementing the 65c02 assembler in Applesoft BASIC and it looks like I should have something
ready to start testing in the next couple of days.

I have committed my current work in progress:
* The BASIC code can be seen 
  [[https://github.com/adamgreen/Retrochallenge-2013SC/blob/e1674b234111fd7cbcb1f8b06475524845422280/files/SASM.BAS | here]].
* I have updated the pseudocode as I have been implementing the BASIC version.  The corresponding pseudocode is located
  [[https://github.com/adamgreen/Retrochallenge-2013SC/blob/e1674b234111fd7cbcb1f8b06475524845422280/notes/pseudocode.creole | here]].
* To help me keep track of how the BASIC code corresponds to the pseudocode, I have created this
  [[https://github.com/adamgreen/Retrochallenge-2013SC/blob/e1674b234111fd7cbcb1f8b06475524845422280/notes/map.creole | mapping document]].
  It maps BASIC line numbers and variable names to the more descriptive function and variable names used in the
  pseudocode.


==July 6th, 2013 - Program Not Brought to you by the Letter J

As I was writing actual BASIC code today, I hit a problem on my Apple IIe that I think has probably existed since I got
the machine but I didn't notice it until now.  **The J key doesn't work!**  I can't believe that I have never tried to
type a **J** until now.  I guess it isn't used much when writing BASIC code :)  I am continuing to work on the challenge
with the broken key for now but at some point I will need access to the J key and at that time I will try to fix the key
and switch to emulation if not successful.

I reread Appendix D: Space Saver and Appendix E: Speeding Up Your Program of the "Applesoft II BASIC Programming Reference Manual".
When implementing the 65c02 assembler, my first priority is to minimize the size of the assembler since I think that it
is going to be a bit on the large side and I still need to fit in DATA statements for the assembly language code to
process.  The second priority will be to make speed optimizations, especially in the really hot code paths.  If I
encounter a conflict between these two priorities as I implement the assembler, I will tend to side with the version of
the code which minimizes size.  Based on these priorities, I have come up with this list of things (most come from the
reference manual) to keep in mind as I write the code:
* Placing multiple statements on one line saves 4 bytes of overhead per source line. **edit:** //I originally indicated
  that it saves 5 bytes per source line but I later noticed that Beagle Brother's D Code documentation correctly points
  out that the colon statement separator uses up one of the saved bytes.//
* Minimize comment text.  I will create pages on github in an attempt to document the code else where and use a minimum
  of comments.
* Make use of variables instead of constants.  This item has a few things to consider though:
** If using a constant (especially those with more than a couple of digits) multiple times then set a variable to the
   value and use it instead.  This also makes things faster since the number doesn't need to be parsed each time.
** If constant not used many times, it will probably grow code to add the extra assignment line but if used in loop then
   might give speed boost from less parsing.
* Use subroutines to remove redundancy from code.
* One character variable names use less space than two character names.  While longer variable names are more meaningful
  to reader, they take up more space in the code.  Again, I will try to use external documentation to provide the reader
  (me in most cases) with an explanation for each short named variable.
* Keep the assembly language code short and sweet as well.  Longer label names require more space.  Comments will use
  more space.  Evening adding more spaces for cleaner formatting will use more space.
* Sort variable in initialization routine so that hot loop variables like i, j, k, etc are at top since linear search is
  used when references are made and they are arranged in init order.
* Just use NEXT, instead of NEXT I.  This eliminates a runtime consistency check.
* May want to place hot routines (code which is called often) closer to beginning of program. Don't place any code in
  first 1000 lines at first so that hot routines can be moved into that area later.


==July 5th, 2013 - Prepared for Coding
I completed my pseudocoding exercise today by adding support for directives, list output generation, and unit
test mode.  I should be able to start actual implementation in Applesoft BASIC this weekend.

[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/pseudocode.creole | Read more...]]


==July 4th, 2013 - Pseudo What?

When writing unstructured line numbered BASIC code, I have found that it helps to have a pretty good idea of what I am
going to write before I even start typing at the keyboard.  It is difficult to move code around with the line number
oriented editing provided by environments like Applesoft BASIC.  To alleviate this in the past I would have thought
through a lot of the code on paper before starting to bang it out on the actual computer.  However with today's full
screen editors, it is much easier to write the pseudo code on a modern PC instead.  It also makes it easier to share the
pseudo code with people here on github.  Speaking of which, you can peruse my 
[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/pseudocode.creole | current rough pseudo code here]].
If that pseudo code happens to resemble C, its only because that is how my demented mind works these days :)  I hope to
finish this pseudo code tomorrow and then start with the Applesoft coding.


==July 3rd, 2013 - What Should this Assembler Do?

I spent time today thinking more about this assembler project and stripping down my
[[https://github.com/adamgreen/snapNcrackle/blob/master/notes/snap.creole | snap assembler documentation]]
to indicate what features I want from this Applesoft BASIC based version.

[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/features.creole | Read more...]]


==July 2nd, 2013 - Applesoft BASIC, Here I Come!

Yesterday was the first day that I really sat at the Apple IIe and typed in some code as I was attempting to learn
Applesoft BASIC.  Using a non-structured line oriented BASIC on such a computer really took me back to my childhood.
While I never owned an Apple II until 2012, the experience does remind me a lot of using my first computer, a Tandy
Color Computer 2.

I also experimented with copying sample disk images from my Apple IIe using [[http://adtpro.sourceforge.net | ADTPro]]
and then extracting the Applesoft BASIC code on my MacBook using 
[[http://applecommander.sourceforge.net | AppleCommander]].  This will allow me to not only commit .DSK images to this
github repository but also the text of the Applesoft BASIC programs so that readers can look at it easily from the
github site.  I just wish that AppleCommander would shutdown cleanly on my MacBook.  Instead it hangs on every shutdown
attempt and I have to forcibly kill it.  These images show a screenshot from the Apple IIe where the code was originally
written and then another screenshot of the same BASIC code being viewed in this github repository.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130702-01.jpg}} 

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130702-02.png}}

I want to maintain a few tables (opcode and directive tables) in DATA statements while also placing the actual assembly
language code to be assembled in DATA statements as well.  The issue I hit with this scenario is that I need to conduct
multiple passes through the assembly code after having read out the tables.  While the RESTORE statement does allow the
DATA pointer to be rewound, it would only rewind to the beginning of the tables and not the assembly language code.
Reading through the Applesoft manual I discovered that there were pointers maintained by the interpreter so that it knew
where the next READ should take place in the DATA stream.  It appears that I could save off these pointers after reading
the tables:
{{{
2000 D1 =  PEEK(123):D2 =  PEEK(124)
2010 D3 =  PEEK(125):D4 =  PEEK(126)
}}}
and then restore them to rewind to the same location:
{{{
2500  POKE 123,D1: POKE 124,D2: POKE 125,D3: POKE 126,D4
}}}
The sample I used to play around with this idea can be found 
[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/01ee6f16e152f41343b3935019a99ac75bb295a0/files/DATA.BAS | here]]

Why do I want to assembly language code to be included in the assembler source itself as DATA statements?  The main
purpose of this project is to explore bootstrapping the development process on an Apple ][e, starting out with just the
software that Apple shipped with the device.  I do admit that I am using one external program, ADTPro, in this project
but it is just being used to facilitate sharing my progress on this site.  To keep with this goal of using only the code
that Apple shipped on the machine, I don't have immediate access to a nice editor with which to write the assembly
language source code.  However, the Apple ][e does provide some rudimentary editing options to be used in the creation
of line numbered Applesoft programs.  Using DATA statements in the assembler code itself allows me to take advantage of
this editing functionality and simplifies the read path in my BASIC code.

I have already decided to make one early compromise to the assembler.  I had originally planned to allow for an ORG
directive which would target the code to a specific load address.  The plan had been to create the machine language
image in one memory location that was available when the BASIC program was running but BSAVE it out to a binary file
with its address set to the specified ORG address.  I haven't found a convenient way to do this in Applesoft BASIC since
it will set the address in the ProDOS directory entry to the one used with the BSAVE.   For now I will just assemble the
code to a fixed address (reserved via the HIMEM statement) and this is the same location it will be placed to execute as
well.  I can remedy this deficiency in the future through the use of machine language code to be called from the BASIC
based assembler.


==July 1st, 2013 - The Challenge has Begun!

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-setup.jpg}}

Today is the first day of the Retrochallenge and I kicked it off by starting to prepare myself for writing some
Applesoft BASIC code on my Aplle ][e.  This preparation included:
* Putting my Apple 5.25" Disk Drive back together.  I took it apart last year after purchasing it on Ebay to clean and
  calibrate it.  I never bothered putting all of the screws back into the drive case until today.  A year later, I can
  say that I have finally completed that project :)
* Connected my Apple ][e up to my Dell 2001FP LCD monitor via the composite input.  Previously I had the Apple ][
  connected to an older CRT Televison.  The 80 column text looks great when connected to this Dell LCD.  That will make
  coding on the actual Apple ][ hardware much easier on the eyes.
* I made sure that ADTPro still worked between my Apple ][e and my MacBookAir.  I plan to use this to take snapshots of
  the disk images as I progress on this challenge and commit them to this github repository.

I will now spend the next couple of days rereading sections of 
[[http://www.amazon.com/New-Apple-II-Users-Guide/dp/0615639879 | David Finnigan's "The New Apple II User's Guide"]]
to reacquaint myself with Applesoft BASIC and ProDOS.  Once I am done with that reading, I can start sketching out the
actual design of my 6502 assembler.


==June 22nd, 2013 - Getting into the Retro Frame of Mind

I figured it was time to get prepared for the Retrochallenge by getting into the right frame of mind.  To that end, I
decided to get an Apple IIc working with [[http://adtpro.sourceforge.net | ADTPro]].  I had previously constructed a
serial cable that worked with my Apple IIe but the Apple IIc has a different connector so I built a new one for it and
then successfully connected ADTPro.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/apple2c-serial-08.jpg}}

[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/apple2c-serial.creole#apple-iic-serial-cable-construction | Read more...]]


==June 14th, 2013 - No Turning Back Now

This project has made it onto the 
[[http://www.wickensonline.co.uk/retrochallenge-2012sc/2013-summer-entrants-list/ | official entrant list for the Retrochallenge]].
There are already some great projects on that list and no doubt there will be even more to come in the near future.
This means I will really have to get heads down and start working on this project at the beginning of July!  No turning
back now :)


==June 12th, 2013 - Project Overview

This is to be my first [[http://retrochallenge.net | Retrochallenge]] attempt. Rather than try to create a serious retro
project, I have decided to do a project for the sake of fun and learning.  My target retro platform for the challenge
will be the Apple ][e Platinum edition machine that I purchased on Ebay last year.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-hardware.JPG}}

If I had had access to this Apple ][e when I was a kid with the slightly more extensive understanding of computers that
I now have, what would my first project have been?  I would definitely have wanted to write programs for it but what
language would I have wanted to use?  6502 assembly language of course!  Now there would have been the rub.  The
computer comes with Applesoft BASIC but no nice symbolic assembler with a nice full screen editor.  I could have
purchased such a set of 6502 assembly language development tools but I am a kid with no money but lots of free time
so the obvious solution would have been to build my own.

My [[http://www.wickensonline.co.uk/retrochallenge-2012sc/ | Retrochallenge - 2013 Summer Challenge]] project will be to
write a simple symbolic 6502 assembler in Applesoft BASIC.  The assembly language program to be assembled will be placed
at the end of the assembler program as DATA statements.  This assembler can be used in the future to develop a full
screen text editor.

**My Challenge Goals:**
* Have Fun.
* Learn more about programming my Apple ][e.
* Write a simple 6502 assembler in AppleSoft BASIC.
* Actually write the code on my Apple ][e and only switch to an emulator if something should break on the real hardware
  during the challenge timeframe.
* Read 6502 assembly language source code from DATA statements appended to the end of the assembler program.
* Output human readable listing output to the screen as part of the assembly process.
* Output a BLOADable program to a ProDOS file.
