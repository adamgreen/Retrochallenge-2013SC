==July 2nd, 2013 - Applesoft BASIC, Here I Come!

Yesterday was the first day that I really sat at the Apple IIe and typed in some code as I was attempting to learn
Applesoft BASIC.  Using a non-structured line oriented BASIC on such a computer really took me back to my childhood.
While I never owned an Apple II until 2012, the experience does remind me a lot of using my first computer, a Tandy
Color Computer 2.

I also experimented with copying sample disk images from my Apple IIe using [[http://adtpro.sourceforge.net | ADTPro]]
and then extracting the Applesoft BASIC code on my MacBook using 
[[http://applecommander.sourceforge.net | AppleCommander]].  This will allow me to not only commit .DSK images to this
github repository but also the text of the Applesoft BASIC programs so that readers can look at it easily from the
github site.  I just wish that AppleCommander would shutdown cleanly on my MacBook.  Instead it hangs on every shutdown
attempt and I have to forcibly kill it.  These images show a screenshot from the Apple IIe where the code was originally
written and then another screenshot of the same BASIC code being viewed in this github repository.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130702-01.jpg}} 

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-20130702-02.png}}

I want to maintain a few tables (opcode and directive tables) in DATA statements while also placing the actual assembly
language code to be assembled in DATA statements as well.  The issue I hit with this scenario is that I need to conduct
multiple passes through the assembly code after having read out the tables.  While the RESTORE statement does allow the
DATA pointer to be rewound, it would only rewind to the beginning of the tables and not the assembly language code.
Reading through the Applesoft manual I discovered that there were pointers maintained by the interpreter so that it knew
where the next READ should take place in the DATA stream.  It appears that I could save off these pointers after reading
the tables:
{{{
2000 D1 =  PEEK(123):D2 =  PEEK(124)
2010 D3 =  PEEK(125):D4 =  PEEK(126)
}}}
and then restore them to rewind to the same location:
{{{
2500  POKE 123,D1: POKE 124,D2: POKE 125,D3: POKE 126,D4
}}}
The sample I used to play around with this idea can be found 
[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/01ee6f16e152f41343b3935019a99ac75bb295a0/files/DATA.BAS | here]]

Why do I want to assembly language code to be included in the assembler source itself as DATA statements?  The main
purpose of this project is to explore bootstrapping the development process on an Apple ][e, starting out with just the
software that Apple shipped with the device.  I do admit that I am using one external program, ADTPro, in this project
but it is just being used to facilitate sharing my progress on this site.  To keep with this goal of using only the code
that Apple shipped on the machine, I don't have immediate access to a nice editor with which to write the assembly
language source code.  However, the Apple ][e does provide some rudimentary editing options to be used in the creation
of line numbered Applesoft programs.  Using DATA statements in the assembler code itself allows me to take advantage of
this editing functionality and simplifies the read path in my BASIC code.

I have already decided to make one early compromise to the assembler.  I had originally planned to allow for an ORG
directive which would target the code to a specific load address.  The plan had been to create the machine language
image in one memory location that was available when the BASIC program was running but BSAVE it out to a binary file
with its address set to the specified ORG address.  I haven't found a convenient way to do this in Applesoft BASIC since
it will set the address in the ProDOS directory entry to the one used with the BSAVE.   For now I will just assemble the
code to a fixed address (reserved via the HIMEM statement) and this is the same location it will be placed to execute as
well.  I can remedy this deficiency in the future through the use of machine language code to be called from the BASIC
based assembler.


==July 1st, 2013 - The Challenge has Begun!

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-setup.jpg}}

Today is the first day of the Retrochallenge and I kicked it off by starting to prepare myself for writing some
Applesoft BASIC code on my Aplle ][e.  This preparation included:
* Putting my Apple 5.25" Disk Drive back together.  I took it apart last year after purchasing it on Ebay to clean and
  calibrate it.  I never bothered putting all of the screws back into the drive case until today.  A year later, I can
  say that I have finally completed that project :)
* Connected my Apple ][e up to my Dell 2001FP LCD monitor via the composite input.  Previously I had the Apple ][
  connected to an older CRT Televison.  The 80 column text looks great when connected to this Dell LCD.  That will make
  coding on the actual Apple ][ hardware much easier on the eyes.
* I made sure that ADTPro still worked between my Apple ][e and my MacBookAir.  I plan to use this to take snapshots of
  the disk images as I progress on this challenge and commit them to this github repository.

I will now spend the next couple of days rereading sections of 
[[http://www.amazon.com/New-Apple-II-Users-Guide/dp/0615639879 | David Finnigan's "The New Apple II User's Guide"]]
to reacquaint myself with Applesoft BASIC and ProDOS.  Once I am done with that reading, I can start sketching out the
actual design of my 6502 assembler.


==June 22nd, 2013 - Getting into the Retro Frame of Mind

I figured it was time to get prepared for the Retrochallenge by getting into the right frame of mind.  To that end, I
decided to get an Apple IIc working with [[http://adtpro.sourceforge.net | ADTPro]].  I had previously constructed a
serial cable that worked with my Apple IIe but the Apple IIc has a different connector so I built a new one for it and
then successfully connected ADTPro.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/apple2c-serial-08.jpg}}

[[https://github.com/adamgreen/Retrochallenge-2013SC/blob/master/notes/apple2c-serial.creole#apple-iic-serial-cable-construction | Read more...]]


==June 14th, 2013 - No Turning Back Now

This project has made it onto the 
[[http://www.wickensonline.co.uk/retrochallenge-2012sc/2013-summer-entrants-list/ | official entrant list for the Retrochallenge]].
There are already some great projects on that list and no doubt there will be even more to come in the near future.
This means I will really have to get heads down and start working on this project at the beginning of July!  No turning
back now :)


==June 12th, 2013 - Project Overview

This is to be my first [[http://retrochallenge.net | Retrochallenge]] attempt. Rather than try to create a serious retro
project, I have decided to do a project for the sake of fun and learning.  My target retro platform for the challenge
will be the Apple ][e Platinum edition machine that I purchased on Ebay last year.

{{https://raw.github.com/adamgreen/Retrochallenge-2013SC/master/photos/rc2013sc-hardware.JPG}}

If I had had access to this Apple ][e when I was a kid with the slightly more extensive understanding of computers that
I now have, what would my first project have been?  I would definitely have wanted to write programs for it but what
language would I have wanted to use?  6502 assembly language of course!  Now there would have been the rub.  The
computer comes with Applesoft BASIC but no nice symbolic assembler with a nice full screen editor.  I could have
purchased such a set of 6502 assembly language development tools but I am a kid with no money but lots of free time
so the obvious solution would have been to build my own.

My [[http://www.wickensonline.co.uk/retrochallenge-2012sc/ | Retrochallenge - 2013 Summer Challenge]] project will be to
write a simple symbolic 6502 assembler in Applesoft BASIC.  The assembly language program to be assembled will be placed
at the end of the assembler program as DATA statements.  This assembler can be used in the future to develop a full
screen text editor.

**My Challenge Goals:**
* Have Fun.
* Learn more about programming my Apple ][e.
* Write a simple 6502 assembler in AppleSoft BASIC.
* Actually write the code on my Apple ][e and only switch to an emulator if something should break on the real hardware
  during the challenge timeframe.
* Read 6502 assembly language source code from DATA statements appended to the end of the assembler program.
* Output human readable listing output to the screen as part of the assembly process.
* Output a BLOADable program to a ProDOS file.
