1  REM  COPYRIGHT 2013 ADAM GREEN (HTTP://GITHUB.COM/ADAMGREEN)
2  REM  LICENSED UNDER THE APACHE LICENSE, VERSION 2.0
3  REM  SEE APACHE.BAS FOR LICENSE INFO.
4  REM 
5  REM  SIMPLE 6502 SYMBOLIC ASSEMBLER
6  GOTO 2000
10  IF I = A% +1  THEN R% = 1: RETURN 
11 T$ =  MID$ (A$,I,1): IF T$ = ";"  THEN C$ =  MID$ (A$,I):R% = 1: RETURN 
12  IF T$ < >"'"  AND T$ < >"`"  THEN 17
13 K = I +1
14  IF K >A%  THEN K = K +1: GOTO 21
15  IF  MID$ (A$,K,1) = T$  THEN K = K +1: GOTO 21
16 K = K +1: GOTO 14
17 K = I
18  IF K >A%  THEN 21
19  IF  MID$ (A$,K,1) = " "  THEN 21
20 K = K +1: GOTO 18
21 T$ =  MID$ (A$,I,K -I):I = K:R% = 0
22  IF I >A%  THEN  RETURN 
23  IF  MID$ (A$,I,1) < >" "  THEN  RETURN 
24 I = I +1: GOTO 22
1000  DATA ADC,105,109,101,255,97,113,117,255,125,121,255,255,255,114
1001  DATA AND,41,45,37,255,33,49,53,255,61,57,255,255,255,50
1002  DATA ASC,0
1003  DATA ASL,255,14,6,10,255,255,22,255,30,255,255,255,255,255
1004  DATA BCC,255,255,255,255,255,255,255,255,255,255,144,255,255,255
1005  DATA BCS,255,255,255,255,255,255,255,255,255,255,176,255,255,255
1006  DATA BEQ,255,255,255,255,255,255,255,255,255,255,240,255,255,255
1007  DATA BIT,137,44,36,255,255,255,52,255,60,255,255,255,255,255
1008  DATA BMI,255,255,255,255,255,255,255,255,255,255,48,255,255,255
1009  DATA BNE,255,255,255,255,255,255,255,255,255,255,208,255,255,255
1010  DATA BPL,255,255,255,255,255,255,255,255,255,255,16,255,255,255
1011  DATA BRA,255,255,255,255,255,255,255,255,255,255,128,255,255,255
1012  DATA BRK,255,255,255,0,255,255,255,255,255,255,255,255,255,255
1013  DATA BVC,255,255,255,255,255,255,255,255,255,255,80,255,255,255
1014  DATA BVS,255,255,255,255,255,255,255,255,255,255,112,255,255,255
1015  DATA CLC,255,255,255,24,255,255,255,255,255,255,255,255,255,255
1016  DATA CLD,255,255,255,216,255,255,255,255,255,255,255,255,255,255
1017  DATA CLI,255,255,255,88,255,255,255,255,255,255,255,255,255,255
1018  DATA CLV,255,255,255,184,255,255,255,255,255,255,255,255,255,255
1019  DATA CMP,201,205,197,255,193,209,213,255,221,217,255,255,255,210
1020  DATA CPX,224,236,228,255,255,255,255,255,255,255,255,255,255,255
1021  DATA CPY,192,204,196,255,255,255,255,255,255,255,255,255,255,255
1022  DATA DB,0
1023  DATA DEC,255,206,198,58,255,255,214,255,222,255,255,255,255,255
1024  DATA DEX,255,255,255,202,255,255,255,255,255,255,255,255,255,255
1025  DATA DEY,255,255,255,136,255,255,255,255,255,255,255,255,255,255
1026  DATA DS,0
1027  DATA DW,0
1028  DATA EOR,73,77,69,255,65,81,85,255,93,89,255,255,255,82
1029  DATA EQU,0
1030  DATA INC,255,238,230,26,255,255,246,255,254,255,255,255,255,255
1031  DATA INX,255,255,255,232,255,255,255,255,255,255,255,255,255,255
1032  DATA INY,255,255,255,200,255,255,255,255,255,255,255,255,255,255
1033  DATA JMP,255,76,255,255,255,255,255,255,255,255,255,108,124,255
1034  DATA JSR,255,32,255,255,255,255,255,255,255,255,255,255,255,255
1035  DATA LDA,169,173,165,255,161,177,181,255,189,185,255,255,255,178
1036  DATA LDX,162,174,166,255,255,255,255,182,255,190,255,255,255,255
1037  DATA LDY,160,172,164,255,255,255,180,255,188,255,255,255,255,255
1038  DATA LSR,255,78,70,74,255,255,86,255,94,255,255,255,255,255
1039  DATA LST,0
1040  DATA NOP,255,255,255,234,255,255,255,255,255,255,255,255,255,255
1041  DATA ORA,9,13,5,255,1,17,21,255,29,25,255,255,255,18
1042  DATA PHA,255,255,255,72,255,255,255,255,255,255,255,255,255,255
1043  DATA PHP,255,255,255,8,255,255,255,255,255,255,255,255,255,255
1044  DATA PHX,255,255,255,218,255,255,255,255,255,255,255,255,255,255
1045  DATA PHY,255,255,255,90,255,255,255,255,255,255,255,255,255,255
1046  DATA PLA,255,255,255,104,255,255,255,255,255,255,255,255,255,255
1047  DATA PLP,255,255,255,40,255,255,255,255,255,255,255,255,255,255
1048  DATA PLX,255,255,255,250,255,255,255,255,255,255,255,255,255,255
1049  DATA PLY,255,255,255,122,255,255,255,255,255,255,255,255,255,255
1050  DATA ROL,255,46,38,42,255,255,54,255,62,255,255,255,255,255
1051  DATA ROR,255,110,102,106,255,255,118,255,126,255,255,255,255,255
1052  DATA RTI,255,255,255,64,255,255,255,255,255,255,255,255,255,255
1053  DATA RTS,255,255,255,96,255,255,255,255,255,255,255,255,255,255
1054  DATA SAV,0
1055  DATA SBC,233,237,229,255,225,241,245,255,253,249,255,255,255,242
1056  DATA SEC,255,255,255,56,255,255,255,255,255,255,255,255,255,255
1057  DATA SED,255,255,255,248,255,255,255,255,255,255,255,255,255,255
1058  DATA SEI,255,255,255,120,255,255,255,255,255,255,255,255,255,255
1059  DATA STA,255,141,133,255,129,145,149,255,157,153,255,255,255,146
1060  DATA STX,255,142,134,255,255,255,255,150,255,255,255,255,255,255
1061  DATA STY,255,140,132,255,255,255,148,255,255,255,255,255,255,255
1062  DATA STZ,255,156,100,255,255,255,116,255,158,255,255,255,255,255
1063  DATA TAX,255,255,255,170,255,255,255,255,255,255,255,255,255,255
1064  DATA TAY,255,255,255,168,255,255,255,255,255,255,255,255,255,255
1065  DATA TRB,255,28,20,255,255,255,255,255,255,255,255,255,255,255
1066  DATA TSB,255,12,4,255,255,255,255,255,255,255,255,255,255,255
1067  DATA TST,0
1068  DATA TSX,255,255,255,186,255,255,255,255,255,255,255,255,255,255
1069  DATA TXA,255,255,255,138,255,255,255,255,255,255,255,255,255,255
1070  DATA TXS,255,255,255,154,255,255,255,255,255,255,255,255,255,255
1071  DATA TYA,255,255,255,152,255,255,255,255,255,255,255,255,255,255
1099  DATA ""
2000  CLEAR : GOSUB 2100: GOSUB 2800: PRINT "ASSEMBLY STARTED":P% = 1: GOSUB 2900: GOSUB 9600:P% = 2: GOSUB 2900: GOSUB 9900: GOSUB 9700: GOSUB 10100: GOSUB 9800: END 
2100  SPEED= 255: TEXT : HOME : GOSUB 2200: GOSUB 2400: GOSUB 10400: GOSUB 2300: GOSUB 2600: RETURN 
2200 P =  PEEK(116) *256 + PEEK(115): IF P = 30208  THEN  RETURN 
2210  IF P < >38400  THEN  PRINT "*HIMEM": STOP 
2220  IF  PEEK(110) *256 + PEEK(109) > = 30208  THEN  PRINT "*NORAM": STOP 
2230  HIMEM: 30208: RETURN 
2300 I = 0:K = 0:A% = 0:A$ = "":T$ = "":R% = 0
2305 LF% = 1:TF% = 0:IC% = 0:DC% = 0:SC% = 0:EC% = 0:TW% = 31232:TR% = 31232:TC% = 0
2310 D$ =  CHR$(4)
2320  DIM O%(13): DIM SN$(255): DIM SV(255)
2330  RETURN 
2400 OC% =  -1
2410  READ T$: IF T$ = ""  THEN  RETURN 
2420 OC% = OC% +1: READ T%: IF T% >0  THEN  GOSUB 2500
2430  GOTO 2410
2500  FOR K = 1 TO 13: READ T%: NEXT : RETURN 
2600  GOSUB 2700:S1% = D1%:S2% = D2%:S3% = D3%:S4% = D4%: RETURN 
2700 D1% =  PEEK(123):D2% =  PEEK(124):D3% =  PEEK(125):D4% =  PEEK(126): RETURN 
2800  RETURN 
2900 P = 31488
2910  GOSUB 3000: GOSUB 3700: IF O$ = "END"  THEN  RETURN 
2920  GOTO 2910
3000  GOSUB 3100: GOSUB 3200: READ A$: GOSUB 2700:A% =  LEN(A$):A = P:Q = 65536:I = 1: GOSUB 10: IF R%  THEN  RETURN 
3010 L$ = T$: GOSUB 10: IF R%  THEN  RETURN 
3020 O$ = T$: GOSUB 10: IF R%  THEN  RETURN 
3030 P$ = T$: GOSUB 10: IF   NOT R%  AND P% = 2  THEN  GOSUB 3600: PRINT "EXTRA_INPUT"
3040  RETURN 
3100 T$ = "":A$ = "":L$ = "":O$ = "":P$ = "":C$ = "":S$ = "":E$ = ""
3110  PRINT D$;"FRE(0)": RETURN 
3200  POKE 123,D1%: POKE 124,D2%: POKE 125,D3%: POKE 126,D4%: RETURN 
3600 EC% = EC% +1: PRINT "LINE:";D2% *256 +D1%;" *";: RETURN 
3700  IF TF%  AND P% = 2  THEN  GOSUB 3800
3710  GOSUB 4300: GOSUB 4600: IF F% = 1  THEN  GOSUB 4900
3720  IF F% = 2  THEN  GOSUB 7700
3730  IF F% = 0  AND O$ < >"END"  AND P% = 2  THEN  GOSUB 3600: PRINT "INVALID_OPCODE"
3740  IF LF%  AND P% = 2  THEN  GOSUB 8800
3750  RETURN 
3800  GOSUB 3900: IF   NOT R%  THEN  RETURN 
3810  GOSUB 4000: RETURN 
3900  IF C$ = ""  THEN  RETURN 
3910  FOR I = 2 TO  LEN(C$):T$ =  MID$ (C$,I,1): IF T$ < >" "  AND (T$ <"0"  OR T$ >"9")  AND (T$ <"A"  OR T$ >"F")  THEN R% = 0: RETURN 
3920  NEXT :R% = 1: RETURN 
4000 I = 2
4010  IF I > =  LEN(C$)  THEN  RETURN 
4020  GOSUB 4100:E$ =  MID$ (C$,I,2):M = 1: GOSUB 6000: GOSUB 4200:I = I +2: GOTO 4010
4100  IF I > =  LEN(C$)  THEN  RETURN 
4110  IF  MID$ (C$,I,1) < >" "  THEN  RETURN 
4120 I = I +1: GOTO 4100
4200  IF TC% = 256  THEN  GOSUB 3600: PRINT "TST_OVER": STOP 
4210  POKE TW%,E:TW% = TW% +1: IF TW% >31487  THEN TW% = 31232
4220 TC% = TC% +1: RETURN 
4300 LI% =  -1: IF L$ = ""  OR P% = 2  THEN  RETURN 
4310 S$ = L$: GOSUB 4400: IF SI% < > -1  THEN  GOSUB 3600: PRINT "DUP_LABEL": RETURN 
4320  GOSUB 4500: IF SI% =  -1  THEN  GOSUB 3600: PRINT "TOO_MANY_LABELS": STOP 
4330 LI% = SI%:SN$(LI%) = L$:SV(LI%) = P: RETURN 
4400  IF SC% = 0  THEN SI% =  -1: RETURN 
4410  FOR M = 0 TO SC% -1: IF SN$(M) = S$  THEN SI% = M: RETURN 
4420  NEXT :SI% =  -1: RETURN 
4500  IF SC% = 256  THEN SI% =  -1: RETURN 
4510 SI% = SC%:SC% = SC% +1: RETURN 
4600 K = 0:M = OC%: IF O$ = ""  THEN F% = 4: RETURN 
4610  IF K >M  THEN F% = 0: RETURN 
4620 I =  INT((M +K)/2): IF O$ <OM$(I)  THEN M = I -1: GOTO 4610
4630  IF O$ >OM$(I)  THEN K = I +1: GOTO 4610
4640  IF OL%(I) <1000  THEN I = OL%(I):F% = 2: RETURN 
4650 T% =  INT(OL%(I)/256): POKE 124,T%: POKE 123,OL%(I) -T% *256:T% =  INT(OP%(I)/256): POKE 126,T%: POKE 125,OP%(I) -T% *256: FOR K = 0 TO 13: READ O%(K): NEXT :F% = 1: RETURN 
4900 L% =  LEN(P$): GOSUB 5000: IF P$ = ""  THEN  GOSUB 5100: RETURN 
4910  IF  MID$ (P$,1,1) = "#"  THEN  GOSUB 5700: RETURN 
4920  GOSUB 6300: IF R%  THEN  GOSUB 6400: RETURN 
4930  GOSUB 6800: IF R%  THEN  GOSUB 6900: RETURN 
4940  GOSUB 7000: IF R%  THEN  GOSUB 7100: RETURN 
4950  GOSUB 7200: IF R%  THEN  GOSUB 7300: RETURN 
4960  GOSUB 7400: IF R%  THEN  GOSUB 7500: RETURN 
4970  GOSUB 7600: RETURN 
5000 OP% =  -1:CP% =  -1:CM% =  -1: IF L% = 0  THEN  RETURN 
5010  FOR I = 1 TO L%:T$ =  MID$ (P$,I,1): IF T$ = "("  THEN OP% = I
5020  IF T$ = ")"  THEN CP% = I
5030  IF T$ = ","  THEN CM% = I
5040  NEXT : RETURN 
5100  IF O%(3) = 255  THEN  GOSUB 5200: RETURN 
5110 X% = O%(3): GOSUB 5300: RETURN 
5200  IF P% = 2  THEN  GOSUB 3600: PRINT "BAD_ADDR"
5210  RETURN 
5300  IF P% = 2  AND X% < > PEEK(P)  THEN  GOSUB 3600: PRINT "PHASE": STOP 
5310  GOSUB 5400: RETURN 
5400  IF P > = 39424  THEN  GOSUB 3600: PRINT "OOM": STOP 
5410  POKE P,X%:P = P +1: IF TF%  AND P% = 2  THEN  GOSUB 5500
5420  RETURN 
5500  GOSUB 5600: IF T% < >X%  THEN  GOSUB 10000
5510  RETURN 
5600  IF TC% = 0  THEN  GOSUB 3600: PRINT "TST_UNDER": STOP 
5610 T% =  PEEK(TR%):TR% = TR% +1: IF TR% >31487  THEN TR% = 31232
5620 TC% = TC% -1: RETURN 
5700  IF 2 >L%  THEN  GOSUB 5800: RETURN 
5710 T$ =  MID$ (P$,2,1): IF T$ = "<"  THEN E$ =  MID$ (P$,3): GOSUB 5900:E = E - INT(E/256) *256: GOTO 5740
5720  IF T$ = ">"  THEN E$ =  MID$ (P$,3): GOSUB 5900:E = (E/256): GOTO 5740
5730 E$ =  MID$ (P$,2): GOSUB 5900
5740  IF O%(0) = 255  THEN  GOSUB 5200: RETURN 
5750  IF E <256  THEN X% = O%(0): GOSUB 5300:X% = E: GOSUB 5400: RETURN 
5760  IF P% = 2  THEN  GOSUB 3600: PRINT "TOO_BIG"
5770  RETURN 
5800 E = 0: IF P% = 2  THEN  GOSUB 3600: PRINT "BAD_EXPR"
5810  RETURN 
5900  IF E$ = ""  THEN  GOSUB 5800: RETURN 
5910 T$ =  MID$ (E$,1,1): IF T$ = "$"  THEN M = 2: GOSUB 6000: RETURN 
5920  IF T$ > = "0"  AND T$ < = "9"  THEN  GOSUB 6100: RETURN 
5930  GOSUB 6200: RETURN 
6000 N% =  LEN(E$): IF N% -M +1 <1  THEN  GOSUB 5800: RETURN 
6010 E = 0
6015  IF M >N%  THEN  RETURN 
6017 T% =  ASC( MID$ (E$,M,1)): IF T% > = 48  AND T% < = 57  THEN T% = T% -48: GOTO 6050
6020  IF T% > = 65  AND T% < = 70  THEN T% = T% -55: GOTO 6050
6030 E = 0: IF P% = 2  THEN  GOSUB 3600: PRINT "BAD_HEX": RETURN 
6040  RETURN 
6050 E = E *16 +T%:M = M +1: GOTO 6015
6100 E =  VAL(E$): RETURN 
6200 S$ = E$: GOSUB 4400: IF SI% < > -1  THEN E = SV(SI%): RETURN 
6210  IF P% = 1  THEN E = 256: RETURN 
6220 E = 256: GOSUB 3600: PRINT "BAD_LABEL": RETURN 
6300 R% = CM% =  -1  AND OP% =  -1  AND CP% =  -1: RETURN 
6400 E$ = P$: GOSUB 5900: IF O%(10) = 255  THEN I = 2:K = 1: GOSUB 6500: RETURN 
6410 E = E -A -2:X% = O%(10): GOSUB 5300: GOSUB 6600
6420  IF P% = 2  AND (E < -128  OR E >127)  THEN  GOSUB 3600: PRINT "TOO_FAR"
6430  RETURN 
6500  IF E <256  AND O%(I) < >255  THEN X% = O%(I): GOSUB 5300: GOSUB 6600: RETURN 
6510  IF O%(K) < >255  THEN X% = O%(K): GOSUB 5300: GOSUB 6700: RETURN 
6520  GOSUB 5200: RETURN 
6600 X% = E - INT(E/256) *256: GOSUB 5400: RETURN 
6700  GOSUB 6600:X% = E/256: GOSUB 5400: RETURN 
6800 R% = CM% < > -1  AND OP% =  -1  AND CP% =  -1: RETURN 
6900 E$ =  MID$ (P$,1,CM% -1): GOSUB 5900:T$ =  MID$ (P$,CM% +1,1): IF T$ = "X"  THEN I = 6:K = 8: GOSUB 6500: RETURN 
6910  IF T$ = "Y"  THEN I = 7:K = 9: GOSUB 6500: RETURN 
6920  GOSUB 5200: RETURN 
7000 R% = CM% < > -1  AND OP% < > -1  AND CP% < > -1  AND CP% >CM%  AND OP% <CM%: RETURN 
7100 E$ =  MID$ (P$,OP% +1,CM% -OP% -1): GOSUB 5900: IF  MID$ (P$,CM% +1,1) < >"X"  THEN  GOSUB 5200: RETURN 
7110 I = 4:K = 12: GOSUB 6500: RETURN 
7200 R% = CM% < > -1  AND OP% < > -1  AND CP% < > -1  AND CP% <CM%  AND OP% <CP%: RETURN 
7300 E$ =  MID$ (P$,OP% +1,CP% -OP% -1): GOSUB 5900: IF  MID$ (P$,CM% +1,1) < >"Y"  THEN  GOSUB 5200: RETURN 
7310  IF E <256  AND O%(5) < >255  THEN X% = O%(5): GOSUB 5300: GOSUB 6600: RETURN 
7320  GOSUB 5200: RETURN 
7400 R% = CM% =  -1  AND OP% < > -1  AND CP% < > -1  AND OP% <CP%: RETURN 
7500 E$ =  MID$ (P$,OP% +1,CP% -OP% -1): GOSUB 5900:I = 13:K = 11: GOSUB 6500: RETURN 
7600  IF P% = 1  THEN  RETURN 
7610  GOSUB 3600: PRINT "BAD_OPERAND": RETURN 
7700 L% =  LEN(P$): ON I +1 GOSUB 7900,8000,8200,8300,8400,8500,8600,8700: RETURN 
7800  FOR I = 1 TO DC%: READ T$: IF T$ = O$  THEN F% = 1: RETURN 
7810  NEXT : RETURN 
7900 T$ =  MID$ (P$,1,1): IF (T$ < >"'"  AND T$ < >"`")  OR  MID$ (P$,L%,1) < >T$  THEN  GOSUB 7600: RETURN 
7910 R% = 0: IF T$ = "`"  THEN R% = 128
7920 L% = L% -1: IF L% >1  THEN  FOR I = 2 TO L%:X% =  ASC( MID$ (P$,I,1)) +R%: GOSUB 5300: NEXT 
7930  RETURN 
8000  FOR I = 1 TO L%: GOSUB 8100:E$ =  MID$ (P$,I,K -I): GOSUB 5900: GOSUB 6600:I = K: NEXT : RETURN 
8100  FOR K = I TO L%: IF  MID$ (P$,K,1) = ","  THEN  RETURN 
8110  NEXT : RETURN 
8200  IF P$ = "/"  THEN E =  INT((P +255)/256) *256 -P: GOTO 8220
8210 E$ = P$: GOSUB 5900
8220  IF E >0  THEN X% = 0: FOR I = 1 TO E: GOSUB 5300: NEXT 
8230  RETURN 
8300  FOR I = 1 TO L%: GOSUB 8100:E$ =  MID$ (P$,I,K -I): GOSUB 5900: GOSUB 6700:I = K: NEXT : RETURN 
8400 E$ = P$: GOSUB 5900: IF P% = 1  AND LI% =  -1  THEN  GOSUB 3600: PRINT "EQU_NOLABEL": RETURN 
8410 Q = E: IF P% = 1  THEN SV(LI%) = E
8420  RETURN 
8500  IF P% = 1  THEN  RETURN 
8510  IF P$ = "ON"  THEN LF% = 1: RETURN 
8520  IF P$ = "OFF"  THEN LF% = 0: RETURN 
8530  GOSUB 7600: RETURN 
8600  IF P$ = ""  THEN  GOSUB 7600: RETURN 
8610  IF P% = 2  AND EC% = 0  THEN  PRINT D$;"BSAVE ";P$;",A31488,L";P -31488
8620  RETURN 
8700 TF% = 1: RETURN 
8800  GOSUB 8900: GOSUB 9000: IF Q < >65536  THEN  GOSUB 9300: PRINT : RETURN 
8810  GOSUB 9400: PRINT : RETURN 
8900 T$ =  STR$(D2% *256 +D1%): PRINT  TAB( 6 - LEN(T$));T$;":";: RETURN 
9000 X% = A/256: GOSUB 9100:X% = A -(X% *256): GOSUB 9100: RETURN 
9100 T% = X%/16: GOSUB 9200:T% = X% -(T% *16): GOSUB 9200: RETURN 
9200  IF T% <10  THEN  PRINT  CHR$(48 +T%);: RETURN 
9210  PRINT  CHR$(55 +T%);: RETURN 
9300  PRINT " =";: GOSUB 10200: GOSUB 9500: RETURN 
9400  IF A = P  THEN 9440
9410  FOR I = 0 TO P -A -1: IF I = 3  THEN  GOSUB 9500
9420  IF I >2  AND  INT(I/3) *3 = I  THEN  PRINT 
9430  HTAB (12 +3 *(I - INT(I/3) *3)):X% =  PEEK(A +I): GOSUB 9100: NEXT 
9440  IF P -A < = 3  THEN  GOSUB 9500
9450  RETURN 
9500  PRINT  TAB( 22);A$;: RETURN 
9600 D1% = S1%:D2% = S2%:D3% = S3%:D4% = S4%: RETURN 
9700  RETURN 
9800  RETURN 
9900  IF P% = 1  OR   NOT TF%  THEN  RETURN 
9910  IF TC% < >0  THEN  GOSUB 10000
9920  RETURN 
10000  GOSUB 3600: PRINT "TST_FAIL": STOP 
10010  RETURN 
10100  IF SC% = 0  THEN 10120
10110  PRINT : FOR I = 0 TO SC% -1: PRINT SN$(I);"= ";:Q = SV(I): GOSUB 10200: PRINT " (";SV(I);")": NEXT 
10120  PRINT : PRINT P -31488;" BYTE(S)": PRINT EC%;" ERROR(S)": RETURN 
10200 X% = Q/256: GOSUB 9100:X% = Q -(X% *256): GOSUB 9100: RETURN 
10400  DIM OM$(OC%): DIM OL%(OC%): DIM OP%(OC%): RESTORE :M = 0: FOR I = 0 TO OC%: READ OM$(I): GOSUB 2700: READ T%: IF T% = 0  THEN OL%(I) = M:M = M +1: GOTO 10420
10410 OL%(I) = D2% *256 +D1%:OP%(I) = D4% *256 +D3%: GOSUB 2500
10420  NEXT : READ T$: RETURN 
32100  DATA "COUT    EQU $FDED"
32120  DATA "GETLN   EQU $FD6A"
32130  DATA "PROMPT  EQU $33"
32140  DATA "IBUF    EQU $200"
32150  DATA "IBUFP   EQU $1FF"
32160  DATA "PRODOS  EQU $BF00"
32170  DATA "PRBYTE  EQU $FDDA"
32180  DATA "SLOT    EQU $FD"
32190  DATA "NIBLO   EQU $00 ; EXPECTED 24-BIT SIZE OF"
32191  DATA "NIBMID  EQU $8E ;  NIBBLE IMAGE (232,960 BYTES)"
32192  DATA "NIBHI   EQU $03"
32193  DATA "RDPGS   EQU $1A ; NUMBER OF PAGES IN NIB TRACK"
32200  DATA "; PRODOS COMMANDS"
32210  DATA "OPEN    EQU $C8"
32211  DATA "READ    EQU $CA"
32212  DATA "CLOSE   EQU $CC"
32213  DATA "SIZE    EQU $D1"
32290  DATA ";"
32293  DATA "; DATA LOCATED BELOW CODE.  ADDRESS EQUS HERE"
32300  DATA "; 6656 BYTE READ BUFFER FOR 1 TRACK OF DATA"
32310  DATA "RDBUFF  EQU $5700"
32320  DATA "RDBUFFE EQU $7100"
32350  DATA "; VARIABLE AREA"
32360  DATA "ERRCODE EQU $7100 ; ERROR DISPLAYED BY PERROR"
32361  DATA "DRIVE   EQU $7101"
32362  DATA "TRACK   EQU $7102"
32363  DATA "TRKBCD  EQU $7103"
32375  DATA "; VARIABLES USED FOR FINDING RUNS"
32376  DATA "DATALO  EQU $7104 ; START OF CURRENT DATA RUN"
32377  DATA "DATAHI  EQU $7105"
32378  DATA "SYNCLO  EQU $7106 ; START OF CURRENT SYNC RUN"
32379  DATA "SYNCHI  EQU $7107"
32380  DATA "VALLO   EQU $7108 ; USE AS GENERIC 16-BIT VALUE"
32381  DATA "VALHI   EQU $7109"
32382  DATA "; STATES USED DURING RUN PROCESSING"
32383  DATA "ST_DATA EQU 0 ; IN DATA BYTES"
32384  DATA "ST_BOTH EQU 1 ; MIGHT BE DATA OR SYNC"
32385  DATA "ST_SYNC EQU 2 ; IN SYNC BYTES"
32400  DATA "; PRODOS 1K FILE BUFFER"
32401  DATA "FBUFF   EQU $7200 ; - $75FF"
32998  DATA ";"
32999  DATA "; MAIN ENTRY POINT"
33000  DATA "        LDA PROMPT"
33010  DATA "        PHA"
33020  DATA "        LDA #$A0"
33030  DATA "        STA PROMPT"
33040  DATA "        JSR GETFNAM"
33140  DATA "M2      JSR CONVSTR"
33150  DATA "        JSR FOPEN"
33160  DATA "        BCS MAINX"
33170  DATA "        JSR GETSLOT"
33180  DATA "        JSR GETDRV"
33200  DATA "        STZ TRACK"
33210  DATA "        LDA #1"
33220  DATA "        STA TRKBCD"
33230  DATA "MLOOP   JSR PRREAD"
33240  DATA "        JSR TRACKRD"
33250  DATA "        JSR TRPRO"
33255  DATA "        JSR PRWRITE"
33260  DATA "        INC TRACK"
33270  DATA "        LDA TRACK"
33280  DATA "        CMP #35"
33290  DATA "        BEQ MAINE"
33300  DATA "        SED"
33310  DATA "        CLC"
33320  DATA "        LDA TRKBCD"
33330  DATA "        ADC #$01"
33340  DATA "        STA TRKBCD"
33350  DATA "        CLD"
33360  DATA "        BRA MLOOP"
33400  DATA "MAINE   ; CLEANUP AND EXIT"
33405  DATA "        JSR CR"
33410  DATA "        JSR FCLOSE"
33460  DATA "MAINX   ; EXIT"
33470  DATA "        PLA ; RESTORE PROMPT BEFORE EXIT"
33480  DATA "        STA PROMPT"
33490  DATA "        RTS"
34000  DATA ";"
34010  DATA "; A:X=NULL TERMINATED STRING TO PRINT"
34020  DATA "PUTS    STX PUTS1"
34030  DATA "        STA PUTS2"
34040  DATA "        LDX #0"
34050  DATA "        PHX"
34060  DATA "PUTSL   PLX"
34070  DATA "        DB $BD ;LDX ????,X"
34080  DATA "PUTS1   DS 1   ; LOW BYTE OF BASEADDR"
34090  DATA "PUTS2   DS 1   ; HIGH BYTE OF BASEADDR"
34100  DATA "        BEQ PUTSX"
34110  DATA "        INX"
34120  DATA "        PHX"
34140  DATA "        JSR COUT"
34150  DATA "        BRA PUTSL"
34160  DATA "PUTSX   RTS"
35000  DATA ";"
35010  DATA "; CONVERT IBUF TO SIZED STRING X=LENGTH"
35020  DATA "CONVSTR LDY #$FF"
35030  DATA "CSL     LDA IBUFP,Y"
35040  DATA "        STA IBUF,Y
35050  DATA "        DEY"
35060  DATA "        BNE CSL"
35070  DATA "        STX IBUF"
35080  DATA "        RTS"
36000  DATA ";"
36010  DATA "; OPEN PRODOS FILE AND SANITY CHECK"
36020  DATA "FOPEN   JSR PRODOS"
36030  DATA "        DB OPEN"
36040  DATA "        DW OPENP"
36150  DATA "        BCC FOPEN1 ; CHECK FOR OPEN ERROR"
36160  DATA "        STA ERRCODE"
36170  DATA "        LDA #>OPENERR"
36180  DATA "        LDX #<OPENERR"
36190  DATA "        JSR PERROR"
36195  DATA "        SEC ; FLAG ERROR"
36200  DATA "        RTS ;  AND RETURN"
36230  DATA "FOPEN1  ;GET FILE SIZE"
36260  DATA "        LDA RREF"
36270  DATA "        STA REF1"
36280  DATA "        JSR PRODOS"
36290  DATA "        DB SIZE"
36300  DATA "        DW SIZEP"
36310  DATA "        BCC FOPEN2"
36320  DATA "        ; ENCOUNTERED GET_EOF ERROR"
36330  DATA "        STA ERRCODE"
36340  DATA "        LDA #>SIZERR"
36350  DATA "        LDX #<SIZERR"
36360  DATA "        JSR PERROR"
36370  DATA "        BRA FOPENC"
36380  DATA "FOPEN2  ; VERIFY THAT FILE IS 232,960 BYTES LONG"
36390  DATA "        LDA SIZELO"
36400  DATA "        CMP #NIBLO"
36410  DATA "        BNE FOPENE"
36420  DATA "        LDA SIZEMID"
36430  DATA "        CMP #NIBMID"
36440  DATA "        BNE FOPENE"
36450  DATA "        LDA SIZEHI"
36460  DATA "        CMP #NIBHI"
36470  DATA "        BNE FOPENE"
36480  DATA "        CLC ; FLAG SUCCESS"
36485  DATA "        RTS ;  AND RETURN"
36490  DATA "FOPENE  ; HANDLE FILE SIZE MISMATCH"
36491  DATA "        LDA #>NOTNIB"
36492  DATA "        LDX #<NOTNIB"
36493  DATA "        JSR PUTS"
36500  DATA "FOPENC  ; CLEANUP ON ERROR"
36510  DATA "        JSR FCLOSE"
36520  DATA "        SEC ; FLAG ERROR"
36530  DATA "        RTS ;  AND RETURN"
36600  DATA "OPENERR ASC `OPEN ERROR: `"
36601  DATA "        DB 0"
36610  DATA "SIZERR  ASC `SIZE ERROR: `"
36611  DATA "        DB 0"
36620  DATA "NOTNIB  ASC `NOT VALID NIBBLE IMAGE`"
36621  DATA "         DB $8D,$00"
36629  DATA "; OPEN PARAMETER BLOCK"
36630  DATA "OPENP   DB 3"
36631  DATA "        DW IBUF ; PATHNAME"
36632  DATA "        DW FBUFF ; 1K FILE BUFFER"
36633  DATA "RREF    DB 0 ; RETURN REFNUM"
36639  DATA "; GET_EOF PARAMETER BLOCK"
36640  DATA "SIZEP   DB 2"
36641  DATA "REF1    DB 0 ; REFNUM"
36642  DATA "SIZELO  DB 0 ; 3-BYTE FILE SIZE"
36643  DATA "SIZEMID DB 0"
36644  DATA "SIZEHI  DB 0"
37000  DATA "        ; PRINT ERROR MESSAGE"
37001  DATA "        ; A:X = ADDRESS OF MESSAGE"
37002  DATA "        ; ERRCODE = ERROR CODE"
37010  DATA "PERROR  JSR PUTS"
37020  DATA "        LDA ERRCODE"
37030  DATA "        JSR PRBYTE"
37040  DATA "        JSR CR"
37050  DATA "        RTS"
38000  DATA ";CLOSE OPEN PRODOS FILE"
38010  DATA "FCLOSE  LDA RREF"
38020  DATA "        STA REF2"
38030  DATA "        JSR PRODOS"
38040  DATA "        DB CLOSE"
38050  DATA "        DW CLOSEP"
38060  DATA "        RTS"
38100  DATA "; CLOSE PARAMETER BLOCK"
38101  DATA "CLOSEP  DB 1"
38102  DATA "REF2    DB 0 ; REFNUM"
39000  DATA "        ; READ TRACK FROM NIBBLE IMAGE"
39010  DATA "TRACKRD LDA RREF"
39020  DATA "        STA REF3"
39100  DATA "        JSR PRODOS"
39110  DATA "        DB READ"
39120  DATA "        DW READP"
39130  DATA "        BCS TRDERR"
39140  DATA "        RTS ; RETURN TO CALLER ON SUCCESS"
39150  DATA "TRDERR  STA ERRCODE"
39155  DATA "        LDA #>RDERR ; SHOW READ ERROR"
39160  DATA "        LDX #<RDERR"
39170  DATA "        JSR PERROR"
39180  DATA "        SEC"
39190  DATA "        RTS"
39900  DATA "RDERR   ASC `READ ERROR: `"
39901  DATA "        DB 0"
39910  DATA "; READ PARAMETER BLOCK"
39911  DATA "READP   DB 4"
39912  DATA "REF3    DB 0 ; REFNUM"
39913  DATA "        DW RDBUFF ; DATA BUFFER"
39914  DATA "        DB 0,RDPGS ; REQUEST LENGTH"
39915  DATA "        DB 0,0 ; ACTUAL LENGTH"
40000  DATA "        ;PROCESS CURRENT TRACK AND SPLIT INTO DATA"
40010  DATA "        ;AND SELF-SYNC BYTE RUNS"
40020  DATA "TRPRO   ;INIT POINTERS AND STATE FOR START OF TRACK"
40030  DATA "        LDA #<RDBUFF"
40040  DATA "        STA CURRLO"
40050  DATA "        LDA #>RDBUFF"
40060  DATA "        STA CURRHI"
40070  DATA "        JSR DATAST"
40080  DATA "        LDY #ST_DATA"
40090  DATA "TPL     ; LOAD NEXT BYTE OF NIBBLE DATA"
40100  DATA "        DB $AD ; LDA
40110  DATA "CURRLO  DB 0   ;  LOBYTE OF ADDRESS"
40120  DATA "CURRHI  DB 0   ;  HIBYTE OF ADDRESS"
40130  DATA "        ; STATE DETERMINES WHAT TO DO NEXT"
40140  DATA "        CPY #ST_DATA"
40150  DATA "        BNE BOTH?"
40160  DATA "        ; STATE == DATA"
40170  DATA "        ; IF SEE A SYNC BYTE THEN ENTER BOTH STATE"
40180  DATA "        CMP #$FF"
40190  DATA "        BNE TPNXT"
40200  DATA "        JSR SYNCST"
40210  DATA "        LDX #3"
40220  DATA "        LDY #ST_BOTH"
40230  DATA "        BRA TPNXT"
40240  DATA "BOTH?   CPY #ST_BOTH"
40250  DATA "        BNE SYNC"
40260  DATA "        ; STATE == BOTH"
40270  DATA "        ; IF NOT SYNC BYTE THEN DATA"
40280  DATA "        CMP #$FF"
40290  DATA "        BEQ TP1"
40300  DATA "        LDY #ST_DATA"
40310  DATA "        BRA TPNXT"
40320  DATA "TP1     ; HAVE SEEN YET ANOTHER SYNC BYTE"
40330  DATA "        DEX"
40340  DATA "        BNE TPNXT"
40350  DATA "        ; SEEN 4 SO COMPLETE PREV DATA RUN"
40360  DATA "        ;  AND START SYNC RUN"
40370  DATA "        JSR DATARUN"
40380  DATA "        LDY #ST_SYNC"
40390  DATA "        BRA TPNXT"
40400  DATA "SYNC    ; STATE == SYNC"
40410  DATA "        CMP #$FF"
40420  DATA "        BEQ TPNXT"
40430  DATA "        ; SEEN START OF DATA RUN SO COMPLETE"
40440  DATA "        ;  SYNC RUN AND START DATA RUN"
40450  DATA "        JSR DATAST"
40460  DATA "        JSR SYNCRUN"
40470  DATA "        LDY #ST_DATA"
40480  DATA "TPNXT   ; INCREMENT CURR POINTER AND LOOP"
40490  DATA "        INC CURRLO"
40500  DATA "        BNE TPL"
40510  DATA "        INC CURRHI"
40520  DATA "        ; DONE PROCESSING TRACK?"
40530  DATA "        LDA CURRHI"
40540  DATA "        CMP #>RDBUFFE"
40550  DATA "        BNE TPL"
40560  DATA "        ; DONE SO COMPLETE LAST RUN"
40570  DATA "        CPY #ST_SYNC"
40580  DATA "        BEQ SYNC2"
40590  DATA "        ; COMPLETE LAST DATA RUN"
40600  DATA "        JSR SYNCST"
40610  DATA "        JMP DATARUN"
40620  DATA "        ; DON'T SUPPORT ENDING IN SYNC RUN"
40630  DATA "SYNC2   LDA #>SYNCERR"
40640  DATA "        LDX #<SYNCERR"
40650  DATA "        JMP PUTS"
40900  DATA "SYNCERR ASC `UNSUPPORTED SELF-SYNC AT END OF TRACK`
40901  DATA "        DB 0"
41000  DATA "SYNCST  ; START SYNC RUN"
41010  DATA "        LDA CURRLO"
41020  DATA "        STA SYNCLO"
41030  DATA "        LDA CURRHI"
41040  DATA "        STA SYNCHI"
41050  DATA "        RTS"
41500  DATA "DATAST  ; START DATA RUN"
41510  DATA "        LDA CURRLO"
41520  DATA "        STA DATALO"
41530  DATA "        LDA CURRHI"
41540  DATA "        STA DATAHI"
41550  DATA "        RTS"
42000  DATA "        ; HANDLE RUN OF DATA BYTES"
42010  DATA "DATARUN ; DO NOTHING AND RETURN"
42020  DATA "        RTS"
43000  DATA "        ; HANDLE RUN OF SYNC BYTES"
43010  DATA "SYNCRUN ; DETERMINE LENGTH OF RUN"
43020  DATA "        SEC"
43030  DATA "        LDA DATALO"
43040  DATA "        SBC SYNCLO"
43050  DATA "        STA VALLO"
43060  DATA "        LDA DATAHI"
43070  DATA "        SBC SYNCHI"
43080  DATA "        STA VALHI"
43090  DATA "        ; PREPARE TO FLAG EACH SELF-SYNC BYTE"
43100  DATA "        LDA SYNCLO"
43110  DATA "        STA SRDSTLO"
43120  DATA "        LDA SYNCHI"
43130  DATA "        STA SRDSTHI"
43140  DATA "        LDX #$7F ; FLAG SELF-SYNC BYTES AS $7F"
43150  DATA "SRL     ; LOOP THROUGH EACH SELF-SYNC BYTE & FLAG"
43160  DATA "        LDA VALLO ; DONE?"
43170  DATA "        ORA VALHI"
43180  DATA "        BNE SR1"
43190  DATA "        RTS ; RETURN WHEN COUNT IS 0"
43200  DATA "SR1     DB $8E ; STX XXXX OPCODE"
43210  DATA "SRDSTLO DB 0"
43220  DATA "SRDSTHI DB 0"
43230  DATA "        ; INCREMENT POINTER TO NEXT BYTE"
43240  DATA "        INC SRDSTLO"
43250  DATA "        BNE SR2"
43260  DATA "        INC SRDSTHI"
43270  DATA "SR2     ; DECREMENT COUNT"
43280  DATA "        LDA VALLO"
43290  DATA "        BNE SR3"
43300  DATA "        DEC VALHI"
43310  DATA "SR3     DEC VALLO"
43320  DATA "        BRA SRL"
44000  DATA "PRVAL   ; PRINT 16-BIT VALUE"
44010  DATA "        LDA VALHI"
44020  DATA "        JSR PRBYTE"
44030  DATA "        LDA VALLO"
44040  DATA "        JSR PRBYTE"
44050  DATA "        RTS"
45000  DATA "        ; SEND CR/LF"
45010  DATA "CR      LDA #$8D"
45020  DATA "        JSR COUT"
45030  DATA "        RTS"
46000  DATA ";"
46010  DATA "; PROMPT USER FOR SLOT #"
46020  DATA "GETSLOT LDA #>PROMPT2"
46030  DATA "        LDX #<PROMPT2"
46040  DATA "        JSR PUTS"
46050  DATA "        JSR GETLN"
46060  DATA "        CPX #2 ; SLOT# SHOULD BE <= 1 DIGIT"
46070  DATA "        BCS GETSLOT"
46080  DATA "        CPX #1 ; DEFAULT TO SLOT 6"
46090  DATA "        BEQ GS1"
46100  DATA "        LDA #$60"
46110  DATA "        STA SLOT"
46120  DATA "        RTS"
46130  DATA "GS1     LDA IBUF ; CHECK SLOT# VALUE"
46140  DATA "        CMP #$B1 ; < 1"
46150  DATA "        BCC GETSLOT"
46160  DATA "        CMP #$B8 ; >= 8"
46170  DATA "        BCS GETSLOT"
46180  DATA "        ; CONVERT INPUT TO SLOT #"
46185  DATA "        SEC"
46190  DATA "        SBC #$B0"
46200  DATA "        ASL"
46201  DATA "        ASL"
46202  DATA "        ASL"
46203  DATA "        ASL"
46210  DATA "        STA SLOT"
46220  DATA "        RTS"
46900  DATA "PROMPT2 ASC `SLOT#: 6`"
46901  DATA "        DB $88,$88,0"
47000  DATA ";"
47010  DATA "; PROMPT USER FOR DRIVE #"
47020  DATA "GETDRV  LDA #>PROMPT3"
47030  DATA "        LDX #<PROMPT3"
47040  DATA "        JSR PUTS"
47050  DATA "        JSR GETLN"
47060  DATA "        CPX #2 ; DRIVE# SHOULD BE <= 1 DIGIT"
47070  DATA "        BCS GETDRV"
47080  DATA "        CPX #1 ; DEFAULT TO DRIVE #1"
47090  DATA "        BEQ GD1"
47100  DATA "        LDA #1"
47110  DATA "        STA DRIVE"
47120  DATA "        RTS"
47130  DATA "GD1     LDA IBUF ; CHECK DRIVE #"
47140  DATA "        CMP #$B1 ; < 1"
47150  DATA "        BCC GETDRV"
47160  DATA "        CMP #$B3 ; >= 3"
47170  DATA "        BCS GETDRV"
47180  DATA "        ; CONVERT INPUT TO DRIVE #"
47190  DATA "        SEC"
47200  DATA "        SBC #$B0"
47210  DATA "        STA DRIVE"
47220  DATA "        RTS"
47230  DATA "PROMPT3 ASC `DRIVE#: 1`"
47231  DATA "        DB $88,$88,0"
48000  DATA ";"
48010  DATA "; PROMPT USER FOR FILENAME"
48020  DATA "GETFNAM LDA #>PROMPT1"
48030  DATA "        LDX #<PROMPT1"
48040  DATA "        JSR PUTS"
48050  DATA "        JSR GETLN"
48060  DATA "        CPX #63 ; PATH TOO LONG?"
48070  DATA "        BCS GF1"
48075  DATA "        RTS"
48080  DATA "GF1     LDA #>LNGPTH"
48090  DATA "        LDX #<LNGPTH"
48100  DATA "        JSR PUTS"
48110  DATA "        BRA GETFNAM"
48900  DATA "PROMPT1 ASC `FILENAME:`"
48901  DATA "        DB 0"
48910  DATA "LNGPTH  ASC `PATH TOO LONG`"
48911  DATA "        DB $8D,$00"
49000  DATA ";"
49010  DATA "; PRINT READING TRACK MSG"
49020  DATA "PRREAD  LDA #>READMSG"
49030  DATA "        LDX #<READMSG"
49040  DATA "        JSR PUTS"
49050  DATA "        JSR PRTRACK"
49060  DATA "        JSR REWIND"
49070  DATA "        RTS"
49900  DATA "READMSG ASC `READING TRACK `"
49901  DATA "        DB 0"
50000  DATA ";"
50005  DATA "; PRINT TRACK NUMBER IN DECIMAL"
50010  DATA "PRTRACK LDA TRKBCD"
50020  DATA "        LSR"
50021  DATA "        LSR"
50022  DATA "        LSR"
50023  DATA "        LSR"
50030  DATA "        BNE PT1"
50040  DATA "        LDA #$A0 ; PRINT LEADING 0 AS SPACE"
50050  DATA "        JSR COUT"
50060  DATA "        BRA PT2"
50070  DATA "PT1     CLC"
50080  DATA "        ADC #$B0 ; BCD TO ASCII"
50090  DATA "        JSR COUT"
50100  DATA "PT2     LDA TRKBCD"
50110  DATA "        AND #$0F"
50120  DATA "        CLC"
50130  DATA "        ADC #$B0 ; BCD TO ASCII"
50140  DATA "        JSR COUT"
50150  DATA "        RTS"
51000  DATA ";"
51010  DATA "; REWIND CURSOR TO START OF LINE"
51020  DATA "REWIND  LDA #>REWTXT"
51030  DATA "        LDX #<REWTXT"
51040  DATA "        JSR PUTS"
51050  DATA "        RTS"
51900  DATA "REWTXT  DB $88,$88,$88,$88,$88,$88,$88,$88"
51901  DATA "        DB $88,$88,$88,$88,$88,$88,$88,$88,$00"
52000  DATA ";"
52010  DATA "; PRINT WRITING TRACK MESSAGE"
52020  DATA "PRWRITE LDA #>WRITMSG"
52030  DATA "        LDX #<WRITMSG"
52040  DATA "        JSR PUTS"
52050  DATA "        JSR PRTRACK"
52060  DATA "        JSR REWIND"
52070  DATA "        RTS"
52080  DATA "WRITMSG ASC `WRITING TRACK `"
52081  DATA "        DB 0"
63998  DATA "        SAV SAMPLE.BIN"
63999  DATA " END"